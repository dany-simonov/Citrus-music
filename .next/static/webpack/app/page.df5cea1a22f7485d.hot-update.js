"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/store/favorites.ts":
/*!********************************!*\
  !*** ./src/store/favorites.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFavoritesStore: function() { return /* binding */ useFavoritesStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/**\r\n * Store для управления избранными треками\r\n * @module store/favorites\r\n */ \n\n// Время жизни кэша - 30 минут\nconst CACHE_TTL = 30 * 60 * 1000;\nconst useFavoritesStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        favorites: [],\n        actionsHistory: [],\n        unreadActionsCount: 0,\n        userId: null,\n        isLoading: false,\n        isInitialized: false,\n        lastFetchedAt: null,\n        isCacheValid: ()=>{\n            const { lastFetchedAt } = get();\n            if (!lastFetchedAt) return false;\n            return Date.now() - lastFetchedAt < CACHE_TTL;\n        },\n        setUserId: (userId)=>{\n            const { userId: currentUserId } = get();\n            // Только если пользователь изменился\n            if (currentUserId !== userId) {\n                set({\n                    userId\n                });\n                if (userId) {\n                    get().loadFavorites(true); // Принудительное обновление при смене пользователя\n                }\n            }\n        },\n        addToFavorites: async (track)=>{\n            const { userId, favorites, actionsHistory, unreadActionsCount } = get();\n            // Проверяем, не добавлен ли уже\n            if (favorites.some((f)=>f.id === track.id)) {\n                return;\n            }\n            const favoriteTrack = {\n                ...track,\n                addedAt: new Date()\n            };\n            // Добавляем в историю действий\n            const action = {\n                type: \"add\",\n                track,\n                timestamp: new Date()\n            };\n            // Добавляем локально (в начало списка)\n            set({\n                favorites: [\n                    favoriteTrack,\n                    ...favorites\n                ],\n                actionsHistory: [\n                    action,\n                    ...actionsHistory\n                ].slice(0, 100),\n                unreadActionsCount: unreadActionsCount + 1\n            });\n            // Синхронизируем с сервером если есть userId\n            if (userId) {\n                try {\n                    await fetch(\"/api/favorites\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            userId,\n                            track\n                        })\n                    });\n                } catch (error) {\n                    console.error(\"Error syncing favorite to server:\", error);\n                }\n            }\n        },\n        removeFromFavorites: async (trackId)=>{\n            const { userId, favorites, actionsHistory, unreadActionsCount } = get();\n            // Находим трек для истории\n            const track = favorites.find((f)=>f.id === trackId);\n            // Добавляем в историю действий\n            if (track) {\n                const action = {\n                    type: \"remove\",\n                    track,\n                    timestamp: new Date()\n                };\n                set({\n                    actionsHistory: [\n                        action,\n                        ...actionsHistory\n                    ].slice(0, 100),\n                    unreadActionsCount: unreadActionsCount + 1\n                });\n            }\n            // Удаляем локально\n            set({\n                favorites: favorites.filter((f)=>f.id !== trackId)\n            });\n            // Синхронизируем с сервером если есть userId\n            if (userId) {\n                try {\n                    await fetch(\"/api/favorites?userId=\".concat(userId, \"&trackId=\").concat(trackId), {\n                        method: \"DELETE\"\n                    });\n                } catch (error) {\n                    console.error(\"Error removing favorite from server:\", error);\n                }\n            }\n        },\n        isFavorite: (trackId)=>{\n            return get().favorites.some((f)=>f.id === trackId);\n        },\n        loadFavorites: async ()=>{\n            const { userId, isLoading } = get();\n            if (!userId || isLoading) return;\n            set({\n                isLoading: true\n            });\n            try {\n                const response = await fetch(\"/api/favorites?userId=\".concat(userId));\n                const data = await response.json();\n                if (data.favorites && data.favorites.length > 0) {\n                    const favorites = data.favorites.map((f)=>({\n                            id: f.trackId,\n                            title: f.title,\n                            artist: f.artist,\n                            duration: f.duration,\n                            coverUrl: f.coverUrl,\n                            audioUrl: f.audioUrl,\n                            source: f.source,\n                            addedAt: new Date(f.addedAt),\n                            isAvailable: !!f.audioUrl\n                        }));\n                    set({\n                        favorites,\n                        isInitialized: true\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error loading favorites:\", error);\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        syncWithServer: async ()=>{\n            const { userId, favorites } = get();\n            if (!userId) return;\n            for (const track of favorites){\n                try {\n                    await fetch(\"/api/favorites\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            userId,\n                            track\n                        })\n                    });\n                } catch (error) {\n                    console.error(\"Error syncing favorite:\", error);\n                }\n            }\n        },\n        // Массовое добавление без дубликатов (для первоначальной загрузки VK)\n        bulkAddToFavorites: (tracks)=>{\n            const { favorites } = get();\n            const existingIds = new Set(favorites.map((f)=>f.id));\n            const newTracks = tracks.filter((t)=>!existingIds.has(t.id)).map((t)=>({\n                    ...t,\n                    addedAt: new Date()\n                }));\n            if (newTracks.length > 0) {\n                // Добавляем новые треки в конец (VK треки как база)\n                set({\n                    favorites: [\n                        ...favorites,\n                        ...newTracks\n                    ],\n                    isInitialized: true\n                });\n            } else {\n                set({\n                    isInitialized: true\n                });\n            }\n        },\n        setInitialized: (value)=>{\n            set({\n                isInitialized: value\n            });\n        },\n        clearFavorites: ()=>{\n            set({\n                favorites: [],\n                isInitialized: false\n            });\n        },\n        clearActionsHistory: ()=>{\n            set({\n                actionsHistory: [],\n                unreadActionsCount: 0\n            });\n        },\n        markHistoryAsRead: ()=>{\n            set({\n                unreadActionsCount: 0\n            });\n        }\n    }), {\n    name: \"citrus-favorites\",\n    partialize: (state)=>({\n            favorites: state.favorites,\n            actionsHistory: state.actionsHistory,\n            unreadActionsCount: state.unreadActionsCount,\n            userId: state.userId,\n            isInitialized: state.isInitialized\n        })\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9mYXZvcml0ZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRWdDO0FBQ1k7QUE2QzdDLDhCQUE4QjtBQUM5QixNQUFNRSxZQUFZLEtBQUssS0FBSztBQUVyQixNQUFNQyxvQkFBb0JILCtDQUFNQSxHQUNyQ0MsMkRBQU9BLENBQ0wsQ0FBQ0csS0FBS0MsTUFBUztRQUNiQyxXQUFXLEVBQUU7UUFDYkMsZ0JBQWdCLEVBQUU7UUFDbEJDLG9CQUFvQjtRQUNwQkMsUUFBUTtRQUNSQyxXQUFXO1FBQ1hDLGVBQWU7UUFDZkMsZUFBZTtRQUVmQyxjQUFjO1lBQ1osTUFBTSxFQUFFRCxhQUFhLEVBQUUsR0FBR1A7WUFDMUIsSUFBSSxDQUFDTyxlQUFlLE9BQU87WUFDM0IsT0FBT0UsS0FBS0MsR0FBRyxLQUFLSCxnQkFBZ0JWO1FBQ3RDO1FBRUFjLFdBQVcsQ0FBQ1A7WUFDVixNQUFNLEVBQUVBLFFBQVFRLGFBQWEsRUFBRSxHQUFHWjtZQUNsQyxxQ0FBcUM7WUFDckMsSUFBSVksa0JBQWtCUixRQUFRO2dCQUM1QkwsSUFBSTtvQkFBRUs7Z0JBQU87Z0JBQ2IsSUFBSUEsUUFBUTtvQkFDVkosTUFBTWEsYUFBYSxDQUFDLE9BQU8sbURBQW1EO2dCQUNoRjtZQUNGO1FBQ0Y7UUFFQUMsZ0JBQWdCLE9BQU9DO1lBQ3JCLE1BQU0sRUFBRVgsTUFBTSxFQUFFSCxTQUFTLEVBQUVDLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR0g7WUFFbEUsZ0NBQWdDO1lBQ2hDLElBQUlDLFVBQVVlLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLSCxNQUFNRyxFQUFFLEdBQUc7Z0JBQzFDO1lBQ0Y7WUFFQSxNQUFNQyxnQkFBK0I7Z0JBQ25DLEdBQUdKLEtBQUs7Z0JBQ1JLLFNBQVMsSUFBSVg7WUFDZjtZQUVBLCtCQUErQjtZQUMvQixNQUFNWSxTQUF5QjtnQkFDN0JDLE1BQU07Z0JBQ05Q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QUNDO1lBQ2Y1RCxJQUFJO2dCQUFFTyxlQUFlcUQ7WUFBTTtRQUM3QjtRQUVBQyxnQkFBZ0I7WUFDZDdELElBQUk7Z0JBQUVFLFdBQVcsRUFBRTtnQkFBRUssZUFBZTtZQUFNO1FBQzVDO1FBRUF1RCxxQkFBcUI7WUFDbkI5RCxJQUFJO2dCQUFFRyxnQkFBZ0IsRUFBRTtnQkFBRUMsb0JBQW9CO1lBQUU7UUFDbEQ7UUFFQTJELG1CQUFtQjtZQUNqQi9ELElBQUk7Z0JBQUVJLG9CQUFvQjtZQUFFO1FBQzlCO0lBQ0YsSUFDQTtJQUNFNEQsTUFBTTtJQUNOQyxZQUFZLENBQUNDLFFBQVc7WUFDdEJoRSxXQUFXZ0UsTUFBTWhFLFNBQVM7WUFDMUJDLGdCQUFnQitELE1BQU0vRCxjQUFjO1lBQ3BDQyxvQkFBb0I4RCxNQUFNOUQsa0JBQWtCO1lBQzVDQyxRQUFRNkQsTUFBTTdELE1BQU07WUFDcEJFLGVBQWUyRCxNQUFNM0QsYUFBYTtRQUNwQztBQUNGLElBRUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0b3JlL2Zhdm9yaXRlcy50cz80MDA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTdG9yZSDQtNC70Y8g0YPQv9GA0LDQstC70LXQvdC40Y8g0LjQt9Cx0YDQsNC90L3Ri9C80Lgg0YLRgNC10LrQsNC80LhcclxuICogQG1vZHVsZSBzdG9yZS9mYXZvcml0ZXNcclxuICovXHJcblxyXG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcclxuaW1wb3J0IHsgcGVyc2lzdCB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XHJcbmltcG9ydCB0eXBlIHsgVHJhY2sgfSBmcm9tICdAL3R5cGVzL2F1ZGlvJztcclxuXHJcbmludGVyZmFjZSBGYXZvcml0ZVRyYWNrIGV4dGVuZHMgVHJhY2sge1xyXG4gIGFkZGVkQXQ6IERhdGU7XHJcbn1cclxuXHJcbi8vINCY0YHRgtC+0YDQuNGPINC00LXQudGB0YLQstC40Lkg0YEg0LjQt9Cx0YDQsNC90L3Ri9C8XHJcbmludGVyZmFjZSBGYXZvcml0ZUFjdGlvbiB7XHJcbiAgdHlwZTogJ2FkZCcgfCAncmVtb3ZlJztcclxuICB0cmFjazogVHJhY2s7XHJcbiAgdGltZXN0YW1wOiBEYXRlO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgRmF2b3JpdGVzU3RhdGUge1xyXG4gIC8vINCU0LDQvdC90YvQtVxyXG4gIGZhdm9yaXRlczogRmF2b3JpdGVUcmFja1tdO1xyXG4gIGFjdGlvbnNIaXN0b3J5OiBGYXZvcml0ZUFjdGlvbltdO1xyXG4gIHVucmVhZEFjdGlvbnNDb3VudDogbnVtYmVyOyAvLyDQmtC+0LvQuNGH0LXRgdGC0LLQviDQvdC10L/RgNC+0YfQuNGC0LDQvdC90YvRhSDQtNC10LnRgdGC0LLQuNC5XHJcbiAgdXNlcklkOiBzdHJpbmcgfCBudWxsO1xyXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcclxuICBpc0luaXRpYWxpemVkOiBib29sZWFuOyAvLyDQpNC70LDQsyDRgdC40L3RhdGA0L7QvdC40LfQsNGG0LjQuCDRgSBWS1xyXG4gIGxhc3RGZXRjaGVkQXQ6IG51bWJlciB8IG51bGw7IC8vINCS0YDQtdC80Y8g0L/QvtGB0LvQtdC00L3QtdC5INC30LDQs9GA0YPQt9C60Lgg0YEg0YHQtdGA0LLQtdGA0LBcclxuICBcclxuICAvLyBBY3Rpb25zXHJcbiAgc2V0VXNlcklkOiAodXNlcklkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xyXG4gIGFkZFRvRmF2b3JpdGVzOiAodHJhY2s6IFRyYWNrKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHJlbW92ZUZyb21GYXZvcml0ZXM6ICh0cmFja0lkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgaXNGYXZvcml0ZTogKHRyYWNrSWQ6IHN0cmluZykgPT4gYm9vbGVhbjtcclxuICBsb2FkRmF2b3JpdGVzOiAoZm9yY2VSZWZyZXNoPzogYm9vbGVhbikgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBzeW5jV2l0aFNlcnZlcjogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBcclxuICAvLyDQnNCw0YHRgdC+0LLQvtC1INC00L7QsdCw0LLQu9C10L3QuNC1ICjQtNC70Y8gVkspXHJcbiAgYnVsa0FkZFRvRmF2b3JpdGVzOiAodHJhY2tzOiBUcmFja1tdKSA9PiB2b2lkO1xyXG4gIHNldEluaXRpYWxpemVkOiAodmFsdWU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgY2xlYXJGYXZvcml0ZXM6ICgpID0+IHZvaWQ7XHJcbiAgY2xlYXJBY3Rpb25zSGlzdG9yeTogKCkgPT4gdm9pZDtcclxuICBcclxuICAvLyDQntGC0LzQtdGC0LjRgtGMINC40YHRgtC+0YDQuNGOINC60LDQuiDQv9GA0L7Rh9C40YLQsNC90L3Rg9GOXHJcbiAgbWFya0hpc3RvcnlBc1JlYWQ6ICgpID0+IHZvaWQ7XHJcbiAgXHJcbiAgLy8g0J/RgNC+0LLQtdGA0LrQsCDQutGN0YjQsFxyXG4gIGlzQ2FjaGVWYWxpZDogKCkgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuLy8g0JLRgNC10LzRjyDQttC40LfQvdC4INC60Y3RiNCwIC0gMzAg0LzQuNC90YPRglxyXG5jb25zdCBDQUNIRV9UVEwgPSAzMCAqIDYwICogMTAwMDtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VGYXZvcml0ZXNTdG9yZSA9IGNyZWF0ZTxGYXZvcml0ZXNTdGF0ZT4oKShcclxuICBwZXJzaXN0KFxyXG4gICAgKHNldCwgZ2V0KSA9PiAoe1xyXG4gICAgICBmYXZvcml0ZXM6IFtdLFxyXG4gICAgICBhY3Rpb25zSGlzdG9yeTogW10sXHJcbiAgICAgIHVucmVhZEFjdGlvbnNDb3VudDogMCxcclxuICAgICAgdXNlcklkOiBudWxsLFxyXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICBpc0luaXRpYWxpemVkOiBmYWxzZSxcclxuICAgICAgbGFzdEZldGNoZWRBdDogbnVsbCxcclxuICAgICAgXHJcbiAgICAgIGlzQ2FjaGVWYWxpZDogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgbGFzdEZldGNoZWRBdCB9ID0gZ2V0KCk7XHJcbiAgICAgICAgaWYgKCFsYXN0RmV0Y2hlZEF0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBsYXN0RmV0Y2hlZEF0IDwgQ0FDSEVfVFRMO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgc2V0VXNlcklkOiAodXNlcklkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQ6IGN1cnJlbnRVc2VySWQgfSA9IGdldCgpO1xyXG4gICAgICAgIC8vINCi0L7Qu9GM0LrQviDQtdGB0LvQuCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Ywg0LjQt9C80LXQvdC40LvRgdGPXHJcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VySWQgIT09IHVzZXJJZCkge1xyXG4gICAgICAgICAgc2V0KHsgdXNlcklkIH0pO1xyXG4gICAgICAgICAgaWYgKHVzZXJJZCkge1xyXG4gICAgICAgICAgICBnZXQoKS5sb2FkRmF2b3JpdGVzKHRydWUpOyAvLyDQn9GA0LjQvdGD0LTQuNGC0LXQu9GM0L3QvtC1INC+0LHQvdC+0LLQu9C10L3QuNC1INC/0YDQuCDRgdC80LXQvdC1INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGFkZFRvRmF2b3JpdGVzOiBhc3luYyAodHJhY2spID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZCwgZmF2b3JpdGVzLCBhY3Rpb25zSGlzdG9yeSwgdW5yZWFkQWN0aW9uc0NvdW50IH0gPSBnZXQoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQn9GA0L7QstC10YDRj9C10LwsINC90LUg0LTQvtCx0LDQstC70LXQvSDQu9C4INGD0LbQtVxyXG4gICAgICAgIGlmIChmYXZvcml0ZXMuc29tZShmID0+IGYuaWQgPT09IHRyYWNrLmlkKSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBmYXZvcml0ZVRyYWNrOiBGYXZvcml0ZVRyYWNrID0ge1xyXG4gICAgICAgICAgLi4udHJhY2ssXHJcbiAgICAgICAgICBhZGRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0JTQvtCx0LDQstC70Y/QtdC8INCyINC40YHRgtC+0YDQuNGOINC00LXQudGB0YLQstC40LlcclxuICAgICAgICBjb25zdCBhY3Rpb246IEZhdm9yaXRlQWN0aW9uID0ge1xyXG4gICAgICAgICAgdHlwZTogJ2FkZCcsXHJcbiAgICAgICAgICB0cmFjayxcclxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCU0L7QsdCw0LLQu9GP0LXQvCDQu9C+0LrQsNC70YzQvdC+ICjQsiDQvdCw0YfQsNC70L4g0YHQv9C40YHQutCwKVxyXG4gICAgICAgIHNldCh7IFxyXG4gICAgICAgICAgZmF2b3JpdGVzOiBbZmF2b3JpdGVUcmFjaywgLi4uZmF2b3JpdGVzXSxcclxuICAgICAgICAgIGFjdGlvbnNIaXN0b3J5OiBbYWN0aW9uLCAuLi5hY3Rpb25zSGlzdG9yeV0uc2xpY2UoMCwgMTAwKSwgLy8g0KXRgNCw0L3QuNC8INC/0L7RgdC70LXQtNC90LjQtSAxMDAg0LTQtdC50YHRgtCy0LjQuVxyXG4gICAgICAgICAgdW5yZWFkQWN0aW9uc0NvdW50OiB1bnJlYWRBY3Rpb25zQ291bnQgKyAxLCAvLyDQo9Cy0LXQu9C40YfQuNCy0LDQtdC8INGB0YfQtdGC0YfQuNC6INC90LXQv9GA0L7Rh9C40YLQsNC90L3Ri9GFXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0KHQuNC90YXRgNC+0L3QuNC30LjRgNGD0LXQvCDRgSDRgdC10YDQstC10YDQvtC8INC10YHQu9C4INC10YHRgtGMIHVzZXJJZFxyXG4gICAgICAgIGlmICh1c2VySWQpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGZldGNoKCcvYXBpL2Zhdm9yaXRlcycsIHtcclxuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJJZCwgdHJhY2sgfSksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3luY2luZyBmYXZvcml0ZSB0byBzZXJ2ZXI6JywgZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIHJlbW92ZUZyb21GYXZvcml0ZXM6IGFzeW5jICh0cmFja0lkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIGZhdm9yaXRlcywgYWN0aW9uc0hpc3RvcnksIHVucmVhZEFjdGlvbnNDb3VudCB9ID0gZ2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0J3QsNGF0L7QtNC40Lwg0YLRgNC10Log0LTQu9GPINC40YHRgtC+0YDQuNC4XHJcbiAgICAgICAgY29uc3QgdHJhY2sgPSBmYXZvcml0ZXMuZmluZChmID0+IGYuaWQgPT09IHRyYWNrSWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCU0L7QsdCw0LLQu9GP0LXQvCDQsiDQuNGB0YLQvtGA0LjRjiDQtNC10LnRgdGC0LLQuNC5XHJcbiAgICAgICAgaWYgKHRyYWNrKSB7XHJcbiAgICAgICAgICBjb25zdCBhY3Rpb246IEZhdm9yaXRlQWN0aW9uID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlJyxcclxuICAgICAgICAgICAgdHJhY2ssXHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBzZXQoeyBcclxuICAgICAgICAgICAgYWN0aW9uc0hpc3Rvcnk6IFthY3Rpb24sIC4uLmFjdGlvbnNIaXN0b3J5XS5zbGljZSgwLCAxMDApLFxyXG4gICAgICAgICAgICB1bnJlYWRBY3Rpb25zQ291bnQ6IHVucmVhZEFjdGlvbnNDb3VudCArIDEsIC8vINCj0LLQtdC70LjRh9C40LLQsNC10Lwg0YHRh9C10YLRh9C40Log0L3QtdC/0YDQvtGH0LjRgtCw0L3QvdGL0YVcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyDQo9C00LDQu9GP0LXQvCDQu9C+0LrQsNC70YzQvdC+XHJcbiAgICAgICAgc2V0KHsgZmF2b3JpdGVzOiBmYXZvcml0ZXMuZmlsdGVyKGYgPT4gZi5pZCAhPT0gdHJhY2tJZCkgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0KHQuNC90YXRgNC+0L3QuNC30LjRgNGD0LXQvCDRgSDRgdC10YDQstC10YDQvtC8INC10YHQu9C4INC10YHRgtGMIHVzZXJJZFxyXG4gICAgICAgIGlmICh1c2VySWQpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGZldGNoKGAvYXBpL2Zhdm9yaXRlcz91c2VySWQ9JHt1c2VySWR9JnRyYWNrSWQ9JHt0cmFja0lkfWAsIHtcclxuICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIGZhdm9yaXRlIGZyb20gc2VydmVyOicsIGVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBpc0Zhdm9yaXRlOiAodHJhY2tJZCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBnZXQoKS5mYXZvcml0ZXMuc29tZShmID0+IGYuaWQgPT09IHRyYWNrSWQpO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgbG9hZEZhdm9yaXRlczogYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCBpc0xvYWRpbmcgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghdXNlcklkIHx8IGlzTG9hZGluZykgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9mYXZvcml0ZXM/dXNlcklkPSR7dXNlcklkfWApO1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGRhdGEuZmF2b3JpdGVzICYmIGRhdGEuZmF2b3JpdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZmF2b3JpdGVzOiBGYXZvcml0ZVRyYWNrW10gPSBkYXRhLmZhdm9yaXRlcy5tYXAoKGY6IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgICBpZDogZi50cmFja0lkLFxyXG4gICAgICAgICAgICAgIHRpdGxlOiBmLnRpdGxlLFxyXG4gICAgICAgICAgICAgIGFydGlzdDogZi5hcnRpc3QsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IGYuZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgY292ZXJVcmw6IGYuY292ZXJVcmwsXHJcbiAgICAgICAgICAgICAgYXVkaW9Vcmw6IGYuYXVkaW9VcmwsXHJcbiAgICAgICAgICAgICAgc291cmNlOiBmLnNvdXJjZSxcclxuICAgICAgICAgICAgICBhZGRlZEF0OiBuZXcgRGF0ZShmLmFkZGVkQXQpLFxyXG4gICAgICAgICAgICAgIGlzQXZhaWxhYmxlOiAhIWYuYXVkaW9VcmwsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgc2V0KHsgZmF2b3JpdGVzLCBpc0luaXRpYWxpemVkOiB0cnVlIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGZhdm9yaXRlczonLCBlcnJvcik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHNldCh7IGlzTG9hZGluZzogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgc3luY1dpdGhTZXJ2ZXI6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZCwgZmF2b3JpdGVzIH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIXVzZXJJZCkgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgZmF2b3JpdGVzKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS9mYXZvcml0ZXMnLCB7XHJcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIHRyYWNrIH0pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN5bmNpbmcgZmF2b3JpdGU6JywgZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIC8vINCc0LDRgdGB0L7QstC+0LUg0LTQvtCx0LDQstC70LXQvdC40LUg0LHQtdC3INC00YPQsdC70LjQutCw0YLQvtCyICjQtNC70Y8g0L/QtdGA0LLQvtC90LDRh9Cw0LvRjNC90L7QuSDQt9Cw0LPRgNGD0LfQutC4IFZLKVxyXG4gICAgICBidWxrQWRkVG9GYXZvcml0ZXM6ICh0cmFja3MpID0+IHtcclxuICAgICAgICBjb25zdCB7IGZhdm9yaXRlcyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGZhdm9yaXRlcy5tYXAoZiA9PiBmLmlkKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbmV3VHJhY2tzOiBGYXZvcml0ZVRyYWNrW10gPSB0cmFja3NcclxuICAgICAgICAgIC5maWx0ZXIodCA9PiAhZXhpc3RpbmdJZHMuaGFzKHQuaWQpKVxyXG4gICAgICAgICAgLm1hcCh0ID0+ICh7XHJcbiAgICAgICAgICAgIC4uLnQsXHJcbiAgICAgICAgICAgIGFkZGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG5ld1RyYWNrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0L3QvtCy0YvQtSDRgtGA0LXQutC4INCyINC60L7QvdC10YYgKFZLINGC0YDQtdC60Lgg0LrQsNC6INCx0LDQt9CwKVxyXG4gICAgICAgICAgc2V0KHsgXHJcbiAgICAgICAgICAgIGZhdm9yaXRlczogWy4uLmZhdm9yaXRlcywgLi4ubmV3VHJhY2tzXSxcclxuICAgICAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZXQoeyBpc0luaXRpYWxpemVkOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIHNldEluaXRpYWxpemVkOiAodmFsdWUpID0+IHtcclxuICAgICAgICBzZXQoeyBpc0luaXRpYWxpemVkOiB2YWx1ZSB9KTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGNsZWFyRmF2b3JpdGVzOiAoKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgZmF2b3JpdGVzOiBbXSwgaXNJbml0aWFsaXplZDogZmFsc2UgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBjbGVhckFjdGlvbnNIaXN0b3J5OiAoKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgYWN0aW9uc0hpc3Rvcnk6IFtdLCB1bnJlYWRBY3Rpb25zQ291bnQ6IDAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBtYXJrSGlzdG9yeUFzUmVhZDogKCkgPT4ge1xyXG4gICAgICAgIHNldCh7IHVucmVhZEFjdGlvbnNDb3VudDogMCB9KTtcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnY2l0cnVzLWZhdm9yaXRlcycsXHJcbiAgICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBmYXZvcml0ZXM6IHN0YXRlLmZhdm9yaXRlcyxcclxuICAgICAgICBhY3Rpb25zSGlzdG9yeTogc3RhdGUuYWN0aW9uc0hpc3RvcnksXHJcbiAgICAgICAgdW5yZWFkQWN0aW9uc0NvdW50OiBzdGF0ZS51bnJlYWRBY3Rpb25zQ291bnQsXHJcbiAgICAgICAgdXNlcklkOiBzdGF0ZS51c2VySWQsXHJcbiAgICAgICAgaXNJbml0aWFsaXplZDogc3RhdGUuaXNJbml0aWFsaXplZCxcclxuICAgICAgfSksXHJcbiAgICB9XHJcbiAgKVxyXG4pO1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsIkNBQ0hFX1RUTCIsInVzZUZhdm9yaXRlc1N0b3JlIiwic2V0IiwiZ2V0IiwiZmF2b3JpdGVzIiwiYWN0aW9uc0hpc3RvcnkiLCJ1bnJlYWRBY3Rpb25zQ291bnQiLCJ1c2VySWQiLCJpc0xvYWRpbmciLCJpc0luaXRpYWxpemVkIiwibGFzdEZldGNoZWRBdCIsImlzQ2FjaGVWYWxpZCIsIkRhdGUiLCJub3ciLCJzZXRVc2VySWQiLCJjdXJyZW50VXNlcklkIiwibG9hZEZhdm9yaXRlcyIsImFkZFRvRmF2b3JpdGVzIiwidHJhY2siLCJzb21lIiwiZiIsImlkIiwiZmF2b3JpdGVUcmFjayIsImFkZGVkQXQiLCJhY3Rpb24iLCJ0eXBlIiwidGltZXN0YW1wIiwic2xpY2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImVycm9yIiwiY29uc29sZSIsInJlbW92ZUZyb21GYXZvcml0ZXMiLCJ0cmFja0lkIiwiZmluZCIsImZpbHRlciIsImlzRmF2b3JpdGUiLCJyZXNwb25zZSIsImRhdGEiLCJqc29uIiwibGVuZ3RoIiwibWFwIiwidGl0bGUiLCJhcnRpc3QiLCJkdXJhdGlvbiIsImNvdmVyVXJsIiwiYXVkaW9VcmwiLCJzb3VyY2UiLCJpc0F2YWlsYWJsZSIsInN5bmNXaXRoU2VydmVyIiwiYnVsa0FkZFRvRmF2b3JpdGVzIiwidHJhY2tzIiwiZXhpc3RpbmdJZHMiLCJTZXQiLCJuZXdUcmFja3MiLCJ0IiwiaGFzIiwic2V0SW5pdGlhbGl6ZWQiLCJ2YWx1ZSIsImNsZWFyRmF2b3JpdGVzIiwiY2xlYXJBY3Rpb25zSGlzdG9yeSIsIm1hcmtIaXN0b3J5QXNSZWFkIiwibmFtZSIsInBhcnRpYWxpemUiLCJzdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/favorites.ts\n"));

/***/ })

});