"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/favorites/page",{

/***/ "(app-pages-browser)/./src/store/playlists.ts":
/*!********************************!*\
  !*** ./src/store/playlists.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePlaylistsStore: function() { return /* binding */ usePlaylistsStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/**\r\n * Store для управления пользовательскими плейлистами\r\n * @module store/playlists\r\n */ \n\n// Время жизни кэша - 30 минут\nconst CACHE_TTL = 30 * 60 * 1000;\nconst usePlaylistsStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        playlists: [],\n        vkPlaylists: [],\n        userId: null,\n        isLoading: false,\n        lastFetchedAt: null,\n        vkPlaylistsLastFetchedAt: null,\n        setUserId: (userId)=>{\n            const { userId: currentUserId } = get();\n            // Только если пользователь изменился\n            if (currentUserId !== userId) {\n                set({\n                    userId\n                });\n                if (userId) {\n                    get().loadPlaylists(true); // Принудительное обновление при смене пользователя\n                }\n            }\n        },\n        isCacheValid: ()=>{\n            const { lastFetchedAt } = get();\n            if (!lastFetchedAt) return false;\n            return Date.now() - lastFetchedAt < CACHE_TTL;\n        },\n        isVKPlaylistsCacheValid: ()=>{\n            const { vkPlaylistsLastFetchedAt } = get();\n            if (!vkPlaylistsLastFetchedAt) return false;\n            return Date.now() - vkPlaylistsLastFetchedAt < CACHE_TTL;\n        },\n        loadPlaylists: async function() {\n            let forceRefresh = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            const { userId, isLoading, isCacheValid, playlists } = get();\n            if (!userId) return;\n            // Не загружаем повторно, если уже загружаем или кэш валиден\n            if (isLoading) return;\n            if (!forceRefresh && isCacheValid() && playlists.length > 0) {\n                console.log(\"[Playlists] Using cached data\");\n                return;\n            }\n            set({\n                isLoading: true\n            });\n            console.log(\"[Playlists] Loading from server...\");\n            try {\n                const response = await fetch(\"/api/playlists?userId=\".concat(userId));\n                const data = await response.json();\n                if (data.playlists) {\n                    const playlists = data.playlists.map((p)=>{\n                        var _p_tracks_, _p_tracks, _p__count, _p_tracks1;\n                        return {\n                            id: p.id,\n                            title: p.title,\n                            description: p.description,\n                            coverUrl: p.coverUrl || ((_p_tracks = p.tracks) === null || _p_tracks === void 0 ? void 0 : (_p_tracks_ = _p_tracks[0]) === null || _p_tracks_ === void 0 ? void 0 : _p_tracks_.coverUrl),\n                            trackCount: ((_p__count = p._count) === null || _p__count === void 0 ? void 0 : _p__count.tracks) || ((_p_tracks1 = p.tracks) === null || _p_tracks1 === void 0 ? void 0 : _p_tracks1.length) || 0,\n                            tracks: (p.tracks || []).map((t)=>({\n                                    id: t.trackId,\n                                    title: t.title,\n                                    artist: t.artist,\n                                    duration: t.duration,\n                                    coverUrl: t.coverUrl,\n                                    audioUrl: t.audioUrl,\n                                    source: t.source,\n                                    isAvailable: !!t.audioUrl\n                                })),\n                            createdAt: new Date(p.createdAt),\n                            updatedAt: new Date(p.updatedAt)\n                        };\n                    });\n                    set({\n                        playlists,\n                        lastFetchedAt: Date.now()\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error loading playlists:\", error);\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        setVKPlaylists: (vkPlaylists)=>{\n            set({\n                vkPlaylists,\n                vkPlaylistsLastFetchedAt: Date.now()\n            });\n            console.log(\"[Playlists] VK playlists cached:\", vkPlaylists.length);\n        },\n        getVKPlaylists: ()=>get().vkPlaylists,\n        createPlaylist: async (title, description)=>{\n            const { userId, playlists } = get();\n            if (!userId) return null;\n            try {\n                const response = await fetch(\"/api/playlists\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        userId,\n                        title,\n                        description\n                    })\n                });\n                const data = await response.json();\n                if (data.playlist) {\n                    const newPlaylist = {\n                        id: data.playlist.id,\n                        title: data.playlist.title,\n                        description: data.playlist.description,\n                        coverUrl: undefined,\n                        trackCount: 0,\n                        tracks: [],\n                        createdAt: new Date(data.playlist.createdAt),\n                        updatedAt: new Date(data.playlist.updatedAt)\n                    };\n                    set({\n                        playlists: [\n                            newPlaylist,\n                            ...playlists\n                        ]\n                    });\n                    return newPlaylist;\n                }\n            } catch (error) {\n                console.error(\"Error creating playlist:\", error);\n            }\n            return null;\n        },\n        deletePlaylist: async (playlistId)=>{\n            const { playlists } = get();\n            // Удаляем локально\n            set({\n                playlists: playlists.filter((p)=>p.id !== playlistId)\n            });\n            try {\n                await fetch(\"/api/playlists?playlistId=\".concat(playlistId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error deleting playlist:\", error);\n            }\n        },\n        updatePlaylist: async (playlistId, data)=>{\n            const { playlists } = get();\n            // Обновляем локально\n            const updatedPlaylists = playlists.map((p)=>{\n                if (p.id === playlistId) {\n                    var _data_description;\n                    return {\n                        ...p,\n                        title: data.name || p.title,\n                        description: (_data_description = data.description) !== null && _data_description !== void 0 ? _data_description : p.description,\n                        updatedAt: new Date()\n                    };\n                }\n                return p;\n            });\n            set({\n                playlists: updatedPlaylists\n            });\n            try {\n                await fetch(\"/api/playlists\", {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        playlistId,\n                        ...data\n                    })\n                });\n            } catch (error) {\n                console.error(\"Error updating playlist:\", error);\n            }\n        },\n        addTrackToPlaylist: async (playlistId, track)=>{\n            const { playlists } = get();\n            const playlist = playlists.find((p)=>p.id === playlistId);\n            if (!playlist) return false;\n            // Проверяем, не добавлен ли уже\n            if (playlist.tracks.some((t)=>t.id === track.id)) {\n                return false;\n            }\n            try {\n                const response = await fetch(\"/api/playlists/tracks\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        playlistId,\n                        track\n                    })\n                });\n                if (response.ok) {\n                    // Обновляем локально\n                    const updatedPlaylists = playlists.map((p)=>{\n                        if (p.id === playlistId) {\n                            return {\n                                ...p,\n                                tracks: [\n                                    ...p.tracks,\n                                    track\n                                ],\n                                trackCount: p.trackCount + 1,\n                                coverUrl: p.coverUrl || track.coverUrl,\n                                updatedAt: new Date()\n                            };\n                        }\n                        return p;\n                    });\n                    set({\n                        playlists: updatedPlaylists\n                    });\n                    return true;\n                }\n                return false;\n            } catch (error) {\n                console.error(\"Error adding track to playlist:\", error);\n                return false;\n            }\n        },\n        removeTrackFromPlaylist: async (playlistId, trackId)=>{\n            const { playlists } = get();\n            // Удаляем локально\n            const updatedPlaylists = playlists.map((p)=>{\n                if (p.id === playlistId) {\n                    var _newTracks_;\n                    const newTracks = p.tracks.filter((t)=>t.id !== trackId);\n                    return {\n                        ...p,\n                        tracks: newTracks,\n                        trackCount: p.trackCount - 1,\n                        coverUrl: (_newTracks_ = newTracks[0]) === null || _newTracks_ === void 0 ? void 0 : _newTracks_.coverUrl,\n                        updatedAt: new Date()\n                    };\n                }\n                return p;\n            });\n            set({\n                playlists: updatedPlaylists\n            });\n            try {\n                await fetch(\"/api/playlists/tracks?playlistId=\".concat(playlistId, \"&trackId=\").concat(trackId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error removing track from playlist:\", error);\n            }\n        },\n        getPlaylist: (playlistId)=>{\n            return get().playlists.find((p)=>p.id === playlistId);\n        }\n    }), {\n    name: \"citrus-user-playlists\",\n    partialize: (state)=>({\n            playlists: state.playlists,\n            vkPlaylists: state.vkPlaylists,\n            userId: state.userId,\n            lastFetchedAt: state.lastFetchedAt,\n            vkPlaylistsLastFetchedAt: state.vkPlaylistsLastFetchedAt\n        })\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9wbGF5bGlzdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRWdDO0FBQ1k7QUF1QjdDLDhCQUE4QjtBQUM5QixNQUFNRSxZQUFZLEtBQUssS0FBSztBQTRCckIsTUFBTUMsb0JBQW9CSCwrQ0FBTUEsR0FDckNDLDJEQUFPQSxDQUNMLENBQUNHLEtBQUtDLE1BQVM7UUFDYkMsV0FBVyxFQUFFO1FBQ2JDLGFBQWEsRUFBRTtRQUNmQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsZUFBZTtRQUNmQywwQkFBMEI7UUFFMUJDLFdBQVcsQ0FBQ0o7WUFDVixNQUFNLEVBQUVBLFFBQVFLLGFBQWEsRUFBRSxHQUFHUjtZQUNsQyxxQ0FBcUM7WUFDckMsSUFBSVEsa0JBQWtCTCxRQUFRO2dCQUM1QkosSUFBSTtvQkFBRUk7Z0JBQU87Z0JBQ2IsSUFBSUEsUUFBUTtvQkFDVkgsTUFBTVMsYUFBYSxDQUFDLE9BQU8sbURBQW1EO2dCQUNoRjtZQUNGO1FBQ0Y7UUFFQUMsY0FBYztZQUNaLE1BQU0sRUFBRUwsYUFBYSxFQUFFLEdBQUdMO1lBQzFCLElBQUksQ0FBQ0ssZUFBZSxPQUFPO1lBQzNCLE9BQU9NLEtBQUtDLEdBQUcsS0FBS1AsZ0JBQWdCUjtRQUN0QztRQUVBZ0IseUJBQXlCO1lBQ3ZCLE1BQU0sRUFBRVAsd0JBQXdCLEVBQUUsR0FBR047WUFDckMsSUFBSSxDQUFDTSwwQkFBMEIsT0FBTztZQUN0QyxPQUFPSyxLQUFLQyxHQUFHLEtBQUtOLDJCQUEyQlQ7UUFDakQ7UUFFQVksZUFBZTtnQkFBT0ssZ0ZBQWU7WUFDbkMsTUFBTSxFQUFFWCxNQUFNLEVBQUVDLFNBQVMsRUFBRU0sWUFBWSxFQUFFVCxTQUFTLEVBQUUsR0FBR0Q7WUFDdkQsSUFBSSxDQUFDRyxRQUFRO1lBRWIsNERBQTREO1lBQzVELElBQUlDLFdBQVc7WUFDZixJQUFJLENBQUNVLGdCQUFnQkosa0JBQWtCVCxVQUFVYyxNQUFNLEdB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O1FBQzVDO0lBQ0YsSUFDQTtJQUNFSSxNQUFNO0lBQ05TLFlBQVksQ0FBQ0MsUUFBVztZQUN0QmxFLFdBQVdrRSxNQUFNbEUsU0FBUztZQUMxQkMsYUFBYWlFLE1BQU1qRSxXQUFXO1lBQzlCQyxRQUFRZ0UsTUFBTWhFLE1BQU07WUFDcEJFLGVBQWU4RCxNQUFNOUQsYUFBYTtZQUNsQ0MsMEJBQTBCNkQsTUFBTTdELHdCQUF3QjtRQUMxRDtBQUNGLElBRUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0b3JlL3BsYXlsaXN0cy50cz8wZmIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTdG9yZSDQtNC70Y8g0YPQv9GA0LDQstC70LXQvdC40Y8g0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GM0YHQutC40LzQuCDQv9C70LXQudC70LjRgdGC0LDQvNC4XHJcbiAqIEBtb2R1bGUgc3RvcmUvcGxheWxpc3RzXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XHJcbmltcG9ydCB7IHBlcnNpc3QgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xyXG5pbXBvcnQgdHlwZSB7IFRyYWNrIH0gZnJvbSAnQC90eXBlcy9hdWRpbyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJQbGF5bGlzdCB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xyXG4gIGNvdmVyVXJsPzogc3RyaW5nO1xyXG4gIHRyYWNrQ291bnQ6IG51bWJlcjtcclxuICB0cmFja3M6IFRyYWNrW107XHJcbiAgY3JlYXRlZEF0OiBEYXRlO1xyXG4gIHVwZGF0ZWRBdDogRGF0ZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWS1BsYXlsaXN0Q2FjaGUge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBjb3Zlcj86IHN0cmluZztcclxuICB0cmFja0NvdW50OiBudW1iZXI7XHJcbiAgb3duZXJJZDogbnVtYmVyO1xyXG4gIGFjY2Vzc0tleT86IHN0cmluZztcclxufVxyXG5cclxuLy8g0JLRgNC10LzRjyDQttC40LfQvdC4INC60Y3RiNCwIC0gMzAg0LzQuNC90YPRglxyXG5jb25zdCBDQUNIRV9UVEwgPSAzMCAqIDYwICogMTAwMDtcclxuXHJcbmludGVyZmFjZSBQbGF5bGlzdHNTdGF0ZSB7XHJcbiAgLy8g0JTQsNC90L3Ri9C1XHJcbiAgcGxheWxpc3RzOiBVc2VyUGxheWxpc3RbXTtcclxuICB2a1BsYXlsaXN0czogVktQbGF5bGlzdENhY2hlW107XHJcbiAgdXNlcklkOiBzdHJpbmcgfCBudWxsO1xyXG4gIGlzTG9hZGluZzogYm9vbGVhbjtcclxuICBsYXN0RmV0Y2hlZEF0OiBudW1iZXIgfCBudWxsO1xyXG4gIHZrUGxheWxpc3RzTGFzdEZldGNoZWRBdDogbnVtYmVyIHwgbnVsbDtcclxuICBcclxuICAvLyBBY3Rpb25zXHJcbiAgc2V0VXNlcklkOiAodXNlcklkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xyXG4gIGxvYWRQbGF5bGlzdHM6IChmb3JjZVJlZnJlc2g/OiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGNyZWF0ZVBsYXlsaXN0OiAodGl0bGU6IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcpID0+IFByb21pc2U8VXNlclBsYXlsaXN0IHwgbnVsbD47XHJcbiAgZGVsZXRlUGxheWxpc3Q6IChwbGF5bGlzdElkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgdXBkYXRlUGxheWxpc3Q6IChwbGF5bGlzdElkOiBzdHJpbmcsIGRhdGE6IHsgbmFtZT86IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmcgfSkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBhZGRUcmFja1RvUGxheWxpc3Q6IChwbGF5bGlzdElkOiBzdHJpbmcsIHRyYWNrOiBUcmFjaykgPT4gUHJvbWlzZTxib29sZWFuPjtcclxuICByZW1vdmVUcmFja0Zyb21QbGF5bGlzdDogKHBsYXlsaXN0SWQ6IHN0cmluZywgdHJhY2tJZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGdldFBsYXlsaXN0OiAocGxheWxpc3RJZDogc3RyaW5nKSA9PiBVc2VyUGxheWxpc3QgfCB1bmRlZmluZWQ7XHJcbiAgXHJcbiAgLy8gVksg0L/Qu9C10LnQu9C40YHRgtGLXHJcbiAgc2V0VktQbGF5bGlzdHM6IChwbGF5bGlzdHM6IFZLUGxheWxpc3RDYWNoZVtdKSA9PiB2b2lkO1xyXG4gIGdldFZLUGxheWxpc3RzOiAoKSA9PiBWS1BsYXlsaXN0Q2FjaGVbXTtcclxuICBpc1ZLUGxheWxpc3RzQ2FjaGVWYWxpZDogKCkgPT4gYm9vbGVhbjtcclxuICBpc0NhY2hlVmFsaWQ6ICgpID0+IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCB1c2VQbGF5bGlzdHNTdG9yZSA9IGNyZWF0ZTxQbGF5bGlzdHNTdGF0ZT4oKShcclxuICBwZXJzaXN0KFxyXG4gICAgKHNldCwgZ2V0KSA9PiAoe1xyXG4gICAgICBwbGF5bGlzdHM6IFtdLFxyXG4gICAgICB2a1BsYXlsaXN0czogW10sXHJcbiAgICAgIHVzZXJJZDogbnVsbCxcclxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgbGFzdEZldGNoZWRBdDogbnVsbCxcclxuICAgICAgdmtQbGF5bGlzdHNMYXN0RmV0Y2hlZEF0OiBudWxsLFxyXG4gICAgICBcclxuICAgICAgc2V0VXNlcklkOiAodXNlcklkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQ6IGN1cnJlbnRVc2VySWQgfSA9IGdldCgpO1xyXG4gICAgICAgIC8vINCi0L7Qu9GM0LrQviDQtdGB0LvQuCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Ywg0LjQt9C80LXQvdC40LvRgdGPXHJcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VySWQgIT09IHVzZXJJZCkge1xyXG4gICAgICAgICAgc2V0KHsgdXNlcklkIH0pO1xyXG4gICAgICAgICAgaWYgKHVzZXJJZCkge1xyXG4gICAgICAgICAgICBnZXQoKS5sb2FkUGxheWxpc3RzKHRydWUpOyAvLyDQn9GA0LjQvdGD0LTQuNGC0LXQu9GM0L3QvtC1INC+0LHQvdC+0LLQu9C10L3QuNC1INC/0YDQuCDRgdC80LXQvdC1INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRj1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGlzQ2FjaGVWYWxpZDogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgbGFzdEZldGNoZWRBdCB9ID0gZ2V0KCk7XHJcbiAgICAgICAgaWYgKCFsYXN0RmV0Y2hlZEF0KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSBsYXN0RmV0Y2hlZEF0IDwgQ0FDSEVfVFRMO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgaXNWS1BsYXlsaXN0c0NhY2hlVmFsaWQ6ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHZrUGxheWxpc3RzTGFzdEZldGNoZWRBdCB9ID0gZ2V0KCk7XHJcbiAgICAgICAgaWYgKCF2a1BsYXlsaXN0c0xhc3RGZXRjaGVkQXQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHZrUGxheWxpc3RzTGFzdEZldGNoZWRBdCA8IENBQ0hFX1RUTDtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGxvYWRQbGF5bGlzdHM6IGFzeW5jIChmb3JjZVJlZnJlc2ggPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCBpc0xvYWRpbmcsIGlzQ2FjaGVWYWxpZCwgcGxheWxpc3RzIH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIXVzZXJJZCkgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCd0LUg0LfQsNCz0YDRg9C20LDQtdC8INC/0L7QstGC0L7RgNC90L4sINC10YHQu9C4INGD0LbQtSDQt9Cw0LPRgNGD0LbQsNC10Lwg0LjQu9C4INC60Y3RiCDQstCw0LvQuNC00LXQvVxyXG4gICAgICAgIGlmIChpc0xvYWRpbmcpIHJldHVybjtcclxuICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBpc0NhY2hlVmFsaWQoKSAmJiBwbGF5bGlzdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1tQbGF5bGlzdHNdIFVzaW5nIGNhY2hlZCBkYXRhJyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW1BsYXlsaXN0c10gTG9hZGluZyBmcm9tIHNlcnZlci4uLicpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3BsYXlsaXN0cz91c2VySWQ9JHt1c2VySWR9YCk7XHJcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoZGF0YS5wbGF5bGlzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcGxheWxpc3RzOiBVc2VyUGxheWxpc3RbXSA9IGRhdGEucGxheWxpc3RzLm1hcCgocDogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICAgIGlkOiBwLmlkLFxyXG4gICAgICAgICAgICAgIHRpdGxlOiBwLnRpdGxlLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBwLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgIGNvdmVyVXJsOiBwLmNvdmVyVXJsIHx8IHAudHJhY2tzPy5bMF0/LmNvdmVyVXJsLFxyXG4gICAgICAgICAgICAgIHRyYWNrQ291bnQ6IHAuX2NvdW50Py50cmFja3MgfHwgcC50cmFja3M/Lmxlbmd0aCB8fCAwLFxyXG4gICAgICAgICAgICAgIHRyYWNrczogKHAudHJhY2tzIHx8IFtdKS5tYXAoKHQ6IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGlkOiB0LnRyYWNrSWQsXHJcbiAgICAgICAgICAgICAgICB0aXRsZTogdC50aXRsZSxcclxuICAgICAgICAgICAgICAgIGFydGlzdDogdC5hcnRpc3QsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdC5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGNvdmVyVXJsOiB0LmNvdmVyVXJsLFxyXG4gICAgICAgICAgICAgICAgYXVkaW9Vcmw6IHQuYXVkaW9VcmwsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHQuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgaXNBdmFpbGFibGU6ICEhdC5hdWRpb1VybCxcclxuICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShwLmNyZWF0ZWRBdCksXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShwLnVwZGF0ZWRBdCksXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgc2V0KHsgcGxheWxpc3RzLCBsYXN0RmV0Y2hlZEF0OiBEYXRlLm5vdygpIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHBsYXlsaXN0czonLCBlcnJvcik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHNldCh7IGlzTG9hZGluZzogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgc2V0VktQbGF5bGlzdHM6ICh2a1BsYXlsaXN0cykgPT4ge1xyXG4gICAgICAgIHNldCh7IHZrUGxheWxpc3RzLCB2a1BsYXlsaXN0c0xhc3RGZXRjaGVkQXQ6IERhdGUubm93KCkgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tQbGF5bGlzdHNdIFZLIHBsYXlsaXN0cyBjYWNoZWQ6JywgdmtQbGF5bGlzdHMubGVuZ3RoKTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGdldFZLUGxheWxpc3RzOiAoKSA9PiBnZXQoKS52a1BsYXlsaXN0cyxcclxuICAgICAgXHJcbiAgICAgIGNyZWF0ZVBsYXlsaXN0OiBhc3luYyAodGl0bGUsIGRlc2NyaXB0aW9uKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHBsYXlsaXN0cyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgaWYgKCF1c2VySWQpIHJldHVybiBudWxsO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3BsYXlsaXN0cycsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJJZCwgdGl0bGUsIGRlc2NyaXB0aW9uIH0pLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChkYXRhLnBsYXlsaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1BsYXlsaXN0OiBVc2VyUGxheWxpc3QgPSB7XHJcbiAgICAgICAgICAgICAgaWQ6IGRhdGEucGxheWxpc3QuaWQsXHJcbiAgICAgICAgICAgICAgdGl0bGU6IGRhdGEucGxheWxpc3QudGl0bGUsXHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRhdGEucGxheWxpc3QuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgY292ZXJVcmw6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICB0cmFja0NvdW50OiAwLFxyXG4gICAgICAgICAgICAgIHRyYWNrczogW10sXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShkYXRhLnBsYXlsaXN0LmNyZWF0ZWRBdCksXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShkYXRhLnBsYXlsaXN0LnVwZGF0ZWRBdCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IFtuZXdQbGF5bGlzdCwgLi4ucGxheWxpc3RzXSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1BsYXlsaXN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBwbGF5bGlzdDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgZGVsZXRlUGxheWxpc3Q6IGFzeW5jIChwbGF5bGlzdElkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBwbGF5bGlzdHMgfSA9IGdldCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCj0LTQsNC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IHBsYXlsaXN0cy5maWx0ZXIocCA9PiBwLmlkICE9PSBwbGF5bGlzdElkKSB9KTtcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXdhaXQgZmV0Y2goYC9hcGkvcGxheWxpc3RzP3BsYXlsaXN0SWQ9JHtwbGF5bGlzdElkfWAsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBwbGF5bGlzdDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgdXBkYXRlUGxheWxpc3Q6IGFzeW5jIChwbGF5bGlzdElkLCBkYXRhKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBwbGF5bGlzdHMgfSA9IGdldCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCDQu9C+0LrQsNC70YzQvdC+XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZFBsYXlsaXN0cyA9IHBsYXlsaXN0cy5tYXAocCA9PiB7XHJcbiAgICAgICAgICBpZiAocC5pZCA9PT0gcGxheWxpc3RJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgdGl0bGU6IGRhdGEubmFtZSB8fCBwLnRpdGxlLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uID8/IHAuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0KHsgcGxheWxpc3RzOiB1cGRhdGVkUGxheWxpc3RzIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9wbGF5bGlzdHNgLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGxheWxpc3RJZCwgLi4uZGF0YSB9KSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwbGF5bGlzdDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgYWRkVHJhY2tUb1BsYXlsaXN0OiBhc3luYyAocGxheWxpc3RJZCwgdHJhY2spID0+IHtcclxuICAgICAgICBjb25zdCB7IHBsYXlsaXN0cyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcGxheWxpc3QgPSBwbGF5bGlzdHMuZmluZChwID0+IHAuaWQgPT09IHBsYXlsaXN0SWQpO1xyXG4gICAgICAgIGlmICghcGxheWxpc3QpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQn9GA0L7QstC10YDRj9C10LwsINC90LUg0LTQvtCx0LDQstC70LXQvSDQu9C4INGD0LbQtVxyXG4gICAgICAgIGlmIChwbGF5bGlzdC50cmFja3Muc29tZSh0ID0+IHQuaWQgPT09IHRyYWNrLmlkKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9wbGF5bGlzdHMvdHJhY2tzJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGxheWxpc3RJZCwgdHJhY2sgfSksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgICAgIC8vINCe0LHQvdC+0LLQu9GP0LXQvCDQu9C+0LrQsNC70YzQvdC+XHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQbGF5bGlzdHMgPSBwbGF5bGlzdHMubWFwKHAgPT4ge1xyXG4gICAgICAgICAgICAgIGlmIChwLmlkID09PSBwbGF5bGlzdElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICAgICAgICB0cmFja3M6IFsuLi5wLnRyYWNrcywgdHJhY2tdLFxyXG4gICAgICAgICAgICAgICAgICB0cmFja0NvdW50OiBwLnRyYWNrQ291bnQgKyAxLFxyXG4gICAgICAgICAgICAgICAgICBjb3ZlclVybDogcC5jb3ZlclVybCB8fCB0cmFjay5jb3ZlclVybCxcclxuICAgICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgc2V0KHsgcGxheWxpc3RzOiB1cGRhdGVkUGxheWxpc3RzIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgdHJhY2sgdG8gcGxheWxpc3Q6JywgZXJyb3IpO1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIHJlbW92ZVRyYWNrRnJvbVBsYXlsaXN0OiBhc3luYyAocGxheWxpc3RJZCwgdHJhY2tJZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgcGxheWxpc3RzIH0gPSBnZXQoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQo9C00LDQu9GP0LXQvCDQu9C+0LrQsNC70YzQvdC+XHJcbiAgICAgICAgY29uc3QgdXBkYXRlZFBsYXlsaXN0cyA9IHBsYXlsaXN0cy5tYXAocCA9PiB7XHJcbiAgICAgICAgICBpZiAocC5pZCA9PT0gcGxheWxpc3RJZCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdUcmFja3MgPSBwLnRyYWNrcy5maWx0ZXIodCA9PiB0LmlkICE9PSB0cmFja0lkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAuLi5wLFxyXG4gICAgICAgICAgICAgIHRyYWNrczogbmV3VHJhY2tzLFxyXG4gICAgICAgICAgICAgIHRyYWNrQ291bnQ6IHAudHJhY2tDb3VudCAtIDEsXHJcbiAgICAgICAgICAgICAgY292ZXJVcmw6IG5ld1RyYWNrc1swXT8uY292ZXJVcmwsXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0KHsgcGxheWxpc3RzOiB1cGRhdGVkUGxheWxpc3RzIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9wbGF5bGlzdHMvdHJhY2tzP3BsYXlsaXN0SWQ9JHtwbGF5bGlzdElkfSZ0cmFja0lkPSR7dHJhY2tJZH1gLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgdHJhY2sgZnJvbSBwbGF5bGlzdDonLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgZ2V0UGxheWxpc3Q6IChwbGF5bGlzdElkKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGdldCgpLnBsYXlsaXN0cy5maW5kKHAgPT4gcC5pZCA9PT0gcGxheWxpc3RJZCk7XHJcbiAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ2NpdHJ1cy11c2VyLXBsYXlsaXN0cycsXHJcbiAgICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBwbGF5bGlzdHM6IHN0YXRlLnBsYXlsaXN0cyxcclxuICAgICAgICB2a1BsYXlsaXN0czogc3RhdGUudmtQbGF5bGlzdHMsXHJcbiAgICAgICAgdXNlcklkOiBzdGF0ZS51c2VySWQsXHJcbiAgICAgICAgbGFzdEZldGNoZWRBdDogc3RhdGUubGFzdEZldGNoZWRBdCxcclxuICAgICAgICB2a1BsYXlsaXN0c0xhc3RGZXRjaGVkQXQ6IHN0YXRlLnZrUGxheWxpc3RzTGFzdEZldGNoZWRBdCxcclxuICAgICAgfSksXHJcbiAgICB9XHJcbiAgKVxyXG4pO1xyXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsIkNBQ0hFX1RUTCIsInVzZVBsYXlsaXN0c1N0b3JlIiwic2V0IiwiZ2V0IiwicGxheWxpc3RzIiwidmtQbGF5bGlzdHMiLCJ1c2VySWQiLCJpc0xvYWRpbmciLCJsYXN0RmV0Y2hlZEF0IiwidmtQbGF5bGlzdHNMYXN0RmV0Y2hlZEF0Iiwic2V0VXNlcklkIiwiY3VycmVudFVzZXJJZCIsImxvYWRQbGF5bGlzdHMiLCJpc0NhY2hlVmFsaWQiLCJEYXRlIiwibm93IiwiaXNWS1BsYXlsaXN0c0NhY2hlVmFsaWQiLCJmb3JjZVJlZnJlc2giLCJsZW5ndGgiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwibWFwIiwicCIsImlkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImNvdmVyVXJsIiwidHJhY2tzIiwidHJhY2tDb3VudCIsIl9jb3VudCIsInQiLCJ0cmFja0lkIiwiYXJ0aXN0IiwiZHVyYXRpb24iLCJhdWRpb1VybCIsInNvdXJjZSIsImlzQXZhaWxhYmxlIiwiY3JlYXRlZEF0IiwidXBkYXRlZEF0IiwiZXJyb3IiLCJzZXRWS1BsYXlsaXN0cyIsImdldFZLUGxheWxpc3RzIiwiY3JlYXRlUGxheWxpc3QiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwbGF5bGlzdCIsIm5ld1BsYXlsaXN0IiwidW5kZWZpbmVkIiwiZGVsZXRlUGxheWxpc3QiLCJwbGF5bGlzdElkIiwiZmlsdGVyIiwidXBkYXRlUGxheWxpc3QiLCJ1cGRhdGVkUGxheWxpc3RzIiwibmFtZSIsImFkZFRyYWNrVG9QbGF5bGlzdCIsInRyYWNrIiwiZmluZCIsInNvbWUiLCJvayIsInJlbW92ZVRyYWNrRnJvbVBsYXlsaXN0IiwibmV3VHJhY2tzIiwiZ2V0UGxheWxpc3QiLCJwYXJ0aWFsaXplIiwic3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/playlists.ts\n"));

/***/ })

});