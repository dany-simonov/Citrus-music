"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/store/playlists.ts":
/*!********************************!*\
  !*** ./src/store/playlists.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePlaylistsStore: function() { return /* binding */ usePlaylistsStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/**\r\n * Store для управления пользовательскими плейлистами\r\n * @module store/playlists\r\n */ \n\n// Время жизни кэша - 30 минут\nconst CACHE_TTL = 30 * 60 * 1000;\nconst usePlaylistsStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        playlists: [],\n        vkPlaylists: [],\n        userId: null,\n        isLoading: false,\n        lastFetchedAt: null,\n        vkPlaylistsLastFetchedAt: null,\n        setUserId: (userId)=>{\n            const { userId: currentUserId } = get();\n            // Только если пользователь изменился\n            if (currentUserId !== userId) {\n                set({\n                    userId\n                });\n                if (userId) {\n                    get().loadPlaylists(true); // Принудительное обновление при смене пользователя\n                }\n            }\n        },\n        isCacheValid: ()=>{\n            const { lastFetchedAt } = get();\n            if (!lastFetchedAt) return false;\n            return Date.now() - lastFetchedAt < CACHE_TTL;\n        },\n        isVKPlaylistsCacheValid: ()=>{\n            const { vkPlaylistsLastFetchedAt } = get();\n            if (!vkPlaylistsLastFetchedAt) return false;\n            return Date.now() - vkPlaylistsLastFetchedAt < CACHE_TTL;\n        },\n        loadPlaylists: async function() {\n            let forceRefresh = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            const { userId, isLoading, isCacheValid, playlists } = get();\n            if (!userId) return;\n            // Не загружаем повторно, если уже загружаем или кэш валиден\n            if (isLoading) return;\n            if (!forceRefresh && isCacheValid() && playlists.length > 0) {\n                console.log(\"[Playlists] Using cached data\");\n                return;\n            }\n            set({\n                isLoading: true\n            });\n            console.log(\"[Playlists] Loading from server...\");\n            try {\n                const response = await fetch(\"/api/playlists?userId=\".concat(userId));\n                const data = await response.json();\n                if (data.playlists) {\n                    const playlists = data.playlists.map((p)=>{\n                        var _p_tracks_, _p_tracks, _p__count, _p_tracks1;\n                        return {\n                            id: p.id,\n                            title: p.title,\n                            description: p.description,\n                            coverUrl: p.coverUrl || ((_p_tracks = p.tracks) === null || _p_tracks === void 0 ? void 0 : (_p_tracks_ = _p_tracks[0]) === null || _p_tracks_ === void 0 ? void 0 : _p_tracks_.coverUrl),\n                            trackCount: ((_p__count = p._count) === null || _p__count === void 0 ? void 0 : _p__count.tracks) || ((_p_tracks1 = p.tracks) === null || _p_tracks1 === void 0 ? void 0 : _p_tracks1.length) || 0,\n                            tracks: (p.tracks || []).map((t)=>({\n                                    id: t.trackId,\n                                    title: t.title,\n                                    artist: t.artist,\n                                    duration: t.duration,\n                                    coverUrl: t.coverUrl,\n                                    audioUrl: t.audioUrl,\n                                    source: t.source,\n                                    isAvailable: !!t.audioUrl\n                                })),\n                            createdAt: new Date(p.createdAt),\n                            updatedAt: new Date(p.updatedAt)\n                        };\n                    });\n                    set({\n                        playlists,\n                        lastFetchedAt: Date.now()\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error loading playlists:\", error);\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        setVKPlaylists: (vkPlaylists)=>{\n            set({\n                vkPlaylists,\n                vkPlaylistsLastFetchedAt: Date.now()\n            });\n            console.log(\"[Playlists] VK playlists cached:\", vkPlaylists.length);\n        },\n        getVKPlaylists: ()=>get().vkPlaylists,\n        createPlaylist: async (title, description)=>{\n            const { userId, playlists } = get();\n            if (!userId) return null;\n            try {\n                const response = await fetch(\"/api/playlists\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        userId,\n                        title,\n                        description\n                    })\n                });\n                const data = await response.json();\n                if (data.playlist) {\n                    const newPlaylist = {\n                        id: data.playlist.id,\n                        title: data.playlist.title,\n                        description: data.playlist.description,\n                        coverUrl: undefined,\n                        trackCount: 0,\n                        tracks: [],\n                        createdAt: new Date(data.playlist.createdAt),\n                        updatedAt: new Date(data.playlist.updatedAt)\n                    };\n                    set({\n                        playlists: [\n                            newPlaylist,\n                            ...playlists\n                        ]\n                    });\n                    return newPlaylist;\n                }\n            } catch (error) {\n                console.error(\"Error creating playlist:\", error);\n            }\n            return null;\n        },\n        deletePlaylist: async (playlistId)=>{\n            const { playlists } = get();\n            // Удаляем локально\n            set({\n                playlists: playlists.filter((p)=>p.id !== playlistId)\n            });\n            try {\n                await fetch(\"/api/playlists?playlistId=\".concat(playlistId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error deleting playlist:\", error);\n            }\n        },\n        updatePlaylist: async (playlistId, data)=>{\n            const { playlists } = get();\n            // Обновляем локально\n            const updatedPlaylists = playlists.map((p)=>{\n                if (p.id === playlistId) {\n                    var _data_description;\n                    return {\n                        ...p,\n                        title: data.name || p.title,\n                        description: (_data_description = data.description) !== null && _data_description !== void 0 ? _data_description : p.description,\n                        updatedAt: new Date()\n                    };\n                }\n                return p;\n            });\n            set({\n                playlists: updatedPlaylists\n            });\n            try {\n                await fetch(\"/api/playlists\", {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        playlistId,\n                        ...data\n                    })\n                });\n            } catch (error) {\n                console.error(\"Error updating playlist:\", error);\n            }\n        },\n        addTrackToPlaylist: async (playlistId, track)=>{\n            const { playlists } = get();\n            const playlist = playlists.find((p)=>p.id === playlistId);\n            if (!playlist) return false;\n            // Проверяем, не добавлен ли уже\n            if (playlist.tracks.some((t)=>t.id === track.id)) {\n                return false;\n            }\n            try {\n                const response = await fetch(\"/api/playlists/tracks\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        playlistId,\n                        track\n                    })\n                });\n                if (response.ok) {\n                    // Обновляем локально\n                    const updatedPlaylists = playlists.map((p)=>{\n                        if (p.id === playlistId) {\n                            return {\n                                ...p,\n                                tracks: [\n                                    ...p.tracks,\n                                    track\n                                ],\n                                trackCount: p.trackCount + 1,\n                                coverUrl: p.coverUrl || track.coverUrl,\n                                updatedAt: new Date()\n                            };\n                        }\n                        return p;\n                    });\n                    set({\n                        playlists: updatedPlaylists\n                    });\n                    return true;\n                }\n                return false;\n            } catch (error) {\n                console.error(\"Error adding track to playlist:\", error);\n                return false;\n            }\n        },\n        removeTrackFromPlaylist: async (playlistId, trackId)=>{\n            const { playlists } = get();\n            // Удаляем локально\n            const updatedPlaylists = playlists.map((p)=>{\n                if (p.id === playlistId) {\n                    var _newTracks_;\n                    const newTracks = p.tracks.filter((t)=>t.id !== trackId);\n                    return {\n                        ...p,\n                        tracks: newTracks,\n                        trackCount: p.trackCount - 1,\n                        coverUrl: (_newTracks_ = newTracks[0]) === null || _newTracks_ === void 0 ? void 0 : _newTracks_.coverUrl,\n                        updatedAt: new Date()\n                    };\n                }\n                return p;\n            });\n            set({\n                playlists: updatedPlaylists\n            });\n            try {\n                await fetch(\"/api/playlists/tracks?playlistId=\".concat(playlistId, \"&trackId=\").concat(trackId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error removing track from playlist:\", error);\n            }\n        },\n        getPlaylist: (playlistId)=>{\n            return get().playlists.find((p)=>p.id === playlistId);\n        }\n    }), {\n    name: \"citrus-user-playlists\",\n    partialize: (state)=>({\n            playlists: state.playlists,\n            userId: state.userId\n        })\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9wbGF5bGlzdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRWdDO0FBQ1k7QUF1QjdDLDhCQUE4QjtBQUM5QixNQUFNRSxZQUFZLEtBQUssS0FBSztBQTRCckIsTUFBTUMsb0JBQW9CSCwrQ0FBTUEsR0FDckNDLDJEQUFPQSxDQUNMLENBQUNHLEtBQUtDLE1BQVM7UUFDYkMsV0FBVyxFQUFFO1FBQ2JDLGFBQWEsRUFBRTtRQUNmQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsZUFBZTtRQUNmQywwQkFBMEI7UUFFMUJDLFdBQVcsQ0FBQ0o7WUFDVixNQUFNLEVBQUVBLFFBQVFLLGFBQWEsRUFBRSxHQUFHUjtZQUNsQyxxQ0FBcUM7WUFDckMsSUFBSVEsa0JBQWtCTCxRQUFRO2dCQUM1QkosSUFBSTtvQkFBRUk7Z0JBQU87Z0JBQ2IsSUFBSUEsUUFBUTtvQkFDVkgsTUFBTVMsYUFBYSxDQUFDLE9BQU8sbURBQW1EO2dCQUNoRjtZQUNGO1FBQ0Y7UUFFQUMsY0FBYztZQUNaLE1BQU0sRUFBRUwsYUFBYSxFQUFFLEdBQUdMO1lBQzFCLElBQUksQ0FBQ0ssZUFBZSxPQUFPO1lBQzNCLE9BQU9NLEtBQUtDLEdBQUcsS0FBS1AsZ0JBQWdCUjtRQUN0QztRQUVBZ0IseUJBQXlCO1lBQ3ZCLE1BQU0sRUFBRVAsd0JBQXdCLEVBQUUsR0FBR047WUFDckMsSUFBSSxDQUFDTSwwQkFBMEIsT0FBTztZQUN0QyxPQUFPSyxLQUFLQyxHQUFHLEtBQUtOLDJCQUEyQlQ7UUFDakQ7UUFFQVksZUFBZTtnQkFBT0ssZ0ZBQWU7WUFDbkMsTUFBTSxFQUFFWCxNQUFNLEVBQUVDLFNBQVMsRUFBRU0sWUFBWSxFQUFFVCxTQUFTLEVBQUUsR0FBR0Q7WUFDdkQsSUFBSSxDQUFDRyxRQUFRO1lBRWIsNERBQTREO1lBQzVELElBQUlDLFdBQVc7WUFDZixJQUFJLENBQUNVLGdCQUFnQkosa0JBQWtCVCxVQUFVYyxNQUFNLEdB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O1FBQzVDO0lBQ0YsSUFDQTtJQUNFSSxNQUFNO0lBQ05TLFlBQVksQ0FBQ0MsUUFBVztZQUN0QmxFLFdBQVdrRSxNQUFNbEUsU0FBUztZQUMxQkUsUUFBUWdFLE1BQU1oRSxNQUFNO1FBQ3RCO0FBQ0YsSUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3RvcmUvcGxheWxpc3RzLnRzPzBmYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFN0b3JlINC00LvRjyDRg9C/0YDQsNCy0LvQtdC90LjRjyDQv9C+0LvRjNC30L7QstCw0YLQtdC70YzRgdC60LjQvNC4INC/0LvQtdC50LvQuNGB0YLQsNC80LhcclxuICogQG1vZHVsZSBzdG9yZS9wbGF5bGlzdHNcclxuICovXHJcblxyXG5pbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcclxuaW1wb3J0IHsgcGVyc2lzdCB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XHJcbmltcG9ydCB0eXBlIHsgVHJhY2sgfSBmcm9tICdAL3R5cGVzL2F1ZGlvJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlclBsYXlsaXN0IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XHJcbiAgY292ZXJVcmw/OiBzdHJpbmc7XHJcbiAgdHJhY2tDb3VudDogbnVtYmVyO1xyXG4gIHRyYWNrczogVHJhY2tbXTtcclxuICBjcmVhdGVkQXQ6IERhdGU7XHJcbiAgdXBkYXRlZEF0OiBEYXRlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZLUGxheWxpc3RDYWNoZSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aXRsZTogc3RyaW5nO1xyXG4gIGNvdmVyPzogc3RyaW5nO1xyXG4gIHRyYWNrQ291bnQ6IG51bWJlcjtcclxuICBvd25lcklkOiBudW1iZXI7XHJcbiAgYWNjZXNzS2V5Pzogc3RyaW5nO1xyXG59XHJcblxyXG4vLyDQktGA0LXQvNGPINC20LjQt9C90Lgg0LrRjdGI0LAgLSAzMCDQvNC40L3Rg9GCXHJcbmNvbnN0IENBQ0hFX1RUTCA9IDMwICogNjAgKiAxMDAwO1xyXG5cclxuaW50ZXJmYWNlIFBsYXlsaXN0c1N0YXRlIHtcclxuICAvLyDQlNCw0L3QvdGL0LVcclxuICBwbGF5bGlzdHM6IFVzZXJQbGF5bGlzdFtdO1xyXG4gIHZrUGxheWxpc3RzOiBWS1BsYXlsaXN0Q2FjaGVbXTtcclxuICB1c2VySWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIGxhc3RGZXRjaGVkQXQ6IG51bWJlciB8IG51bGw7XHJcbiAgdmtQbGF5bGlzdHNMYXN0RmV0Y2hlZEF0OiBudW1iZXIgfCBudWxsO1xyXG4gIFxyXG4gIC8vIEFjdGlvbnNcclxuICBzZXRVc2VySWQ6ICh1c2VySWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XHJcbiAgbG9hZFBsYXlsaXN0czogKGZvcmNlUmVmcmVzaD86IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD47XHJcbiAgY3JlYXRlUGxheWxpc3Q6ICh0aXRsZTogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZykgPT4gUHJvbWlzZTxVc2VyUGxheWxpc3QgfCBudWxsPjtcclxuICBkZWxldGVQbGF5bGlzdDogKHBsYXlsaXN0SWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICB1cGRhdGVQbGF5bGlzdDogKHBsYXlsaXN0SWQ6IHN0cmluZywgZGF0YTogeyBuYW1lPzogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9KSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGFkZFRyYWNrVG9QbGF5bGlzdDogKHBsYXlsaXN0SWQ6IHN0cmluZywgdHJhY2s6IFRyYWNrKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xyXG4gIHJlbW92ZVRyYWNrRnJvbVBsYXlsaXN0OiAocGxheWxpc3RJZDogc3RyaW5nLCB0cmFja0lkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgZ2V0UGxheWxpc3Q6IChwbGF5bGlzdElkOiBzdHJpbmcpID0+IFVzZXJQbGF5bGlzdCB8IHVuZGVmaW5lZDtcclxuICBcclxuICAvLyBWSyDQv9C70LXQudC70LjRgdGC0YtcclxuICBzZXRWS1BsYXlsaXN0czogKHBsYXlsaXN0czogVktQbGF5bGlzdENhY2hlW10pID0+IHZvaWQ7XHJcbiAgZ2V0VktQbGF5bGlzdHM6ICgpID0+IFZLUGxheWxpc3RDYWNoZVtdO1xyXG4gIGlzVktQbGF5bGlzdHNDYWNoZVZhbGlkOiAoKSA9PiBib29sZWFuO1xyXG4gIGlzQ2FjaGVWYWxpZDogKCkgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHVzZVBsYXlsaXN0c1N0b3JlID0gY3JlYXRlPFBsYXlsaXN0c1N0YXRlPigpKFxyXG4gIHBlcnNpc3QoXHJcbiAgICAoc2V0LCBnZXQpID0+ICh7XHJcbiAgICAgIHBsYXlsaXN0czogW10sXHJcbiAgICAgIHZrUGxheWxpc3RzOiBbXSxcclxuICAgICAgdXNlcklkOiBudWxsLFxyXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICBsYXN0RmV0Y2hlZEF0OiBudWxsLFxyXG4gICAgICB2a1BsYXlsaXN0c0xhc3RGZXRjaGVkQXQ6IG51bGwsXHJcbiAgICAgIFxyXG4gICAgICBzZXRVc2VySWQ6ICh1c2VySWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZDogY3VycmVudFVzZXJJZCB9ID0gZ2V0KCk7XHJcbiAgICAgICAgLy8g0KLQvtC70YzQutC+INC10YHQu9C4INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjCDQuNC30LzQtdC90LjQu9GB0Y9cclxuICAgICAgICBpZiAoY3VycmVudFVzZXJJZCAhPT0gdXNlcklkKSB7XHJcbiAgICAgICAgICBzZXQoeyB1c2VySWQgfSk7XHJcbiAgICAgICAgICBpZiAodXNlcklkKSB7XHJcbiAgICAgICAgICAgIGdldCgpLmxvYWRQbGF5bGlzdHModHJ1ZSk7IC8vINCf0YDQuNC90YPQtNC40YLQtdC70YzQvdC+0LUg0L7QsdC90L7QstC70LXQvdC40LUg0L/RgNC4INGB0LzQtdC90LUg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgaXNDYWNoZVZhbGlkOiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBsYXN0RmV0Y2hlZEF0IH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIWxhc3RGZXRjaGVkQXQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxhc3RGZXRjaGVkQXQgPCBDQUNIRV9UVEw7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBpc1ZLUGxheWxpc3RzQ2FjaGVWYWxpZDogKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdmtQbGF5bGlzdHNMYXN0RmV0Y2hlZEF0IH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIXZrUGxheWxpc3RzTGFzdEZldGNoZWRBdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdmtQbGF5bGlzdHNMYXN0RmV0Y2hlZEF0IDwgQ0FDSEVfVFRMO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgbG9hZFBsYXlsaXN0czogYXN5bmMgKGZvcmNlUmVmcmVzaCA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIGlzTG9hZGluZywgaXNDYWNoZVZhbGlkLCBwbGF5bGlzdHMgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghdXNlcklkKSByZXR1cm47XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0J3QtSDQt9Cw0LPRgNGD0LbQsNC10Lwg0L/QvtCy0YLQvtGA0L3Qviwg0LXRgdC70Lgg0YPQttC1INC30LDQs9GA0YPQttCw0LXQvCDQuNC70Lgg0LrRjdGIINCy0LDQu9C40LTQtdC9XHJcbiAgICAgICAgaWYgKGlzTG9hZGluZykgcmV0dXJuO1xyXG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIGlzQ2FjaGVWYWxpZCgpICYmIHBsYXlsaXN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1BsYXlsaXN0c10gVXNpbmcgY2FjaGVkIGRhdGEnKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbUGxheWxpc3RzXSBMb2FkaW5nIGZyb20gc2VydmVyLi4uJyk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvcGxheWxpc3RzP3VzZXJJZD0ke3VzZXJJZH1gKTtcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChkYXRhLnBsYXlsaXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBwbGF5bGlzdHM6IFVzZXJQbGF5bGlzdFtdID0gZGF0YS5wbGF5bGlzdHMubWFwKChwOiBhbnkpID0+ICh7XHJcbiAgICAgICAgICAgICAgaWQ6IHAuaWQsXHJcbiAgICAgICAgICAgICAgdGl0bGU6IHAudGl0bGUsXHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHAuZGVzY3JpcHRpb24sXHJcbiAgICAgICAgICAgICAgY292ZXJVcmw6IHAuY292ZXJVcmwgfHwgcC50cmFja3M/LlswXT8uY292ZXJVcmwsXHJcbiAgICAgICAgICAgICAgdHJhY2tDb3VudDogcC5fY291bnQ/LnRyYWNrcyB8fCBwLnRyYWNrcz8ubGVuZ3RoIHx8IDAsXHJcbiAgICAgICAgICAgICAgdHJhY2tzOiAocC50cmFja3MgfHwgW10pLm1hcCgodDogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IHQudHJhY2tJZCxcclxuICAgICAgICAgICAgICAgIHRpdGxlOiB0LnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgYXJ0aXN0OiB0LmFydGlzdCxcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0LmR1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgY292ZXJVcmw6IHQuY292ZXJVcmwsXHJcbiAgICAgICAgICAgICAgICBhdWRpb1VybDogdC5hdWRpb1VybCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogdC5zb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBpc0F2YWlsYWJsZTogISF0LmF1ZGlvVXJsLFxyXG4gICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHAuY3JlYXRlZEF0KSxcclxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKHAudXBkYXRlZEF0KSxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBzZXQoeyBwbGF5bGlzdHMsIGxhc3RGZXRjaGVkQXQ6IERhdGUubm93KCkgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcGxheWxpc3RzOicsIGVycm9yKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiBmYWxzZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBzZXRWS1BsYXlsaXN0czogKHZrUGxheWxpc3RzKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgdmtQbGF5bGlzdHMsIHZrUGxheWxpc3RzTGFzdEZldGNoZWRBdDogRGF0ZS5ub3coKSB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW1BsYXlsaXN0c10gVksgcGxheWxpc3RzIGNhY2hlZDonLCB2a1BsYXlsaXN0cy5sZW5ndGgpO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgZ2V0VktQbGF5bGlzdHM6ICgpID0+IGdldCgpLnZrUGxheWxpc3RzLFxyXG4gICAgICBcclxuICAgICAgY3JlYXRlUGxheWxpc3Q6IGFzeW5jICh0aXRsZSwgZGVzY3JpcHRpb24pID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZCwgcGxheWxpc3RzIH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIXVzZXJJZCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcGxheWxpc3RzJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCB0aXRsZSwgZGVzY3JpcHRpb24gfSksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGRhdGEucGxheWxpc3QpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3UGxheWxpc3Q6IFVzZXJQbGF5bGlzdCA9IHtcclxuICAgICAgICAgICAgICBpZDogZGF0YS5wbGF5bGlzdC5pZCxcclxuICAgICAgICAgICAgICB0aXRsZTogZGF0YS5wbGF5bGlzdC50aXRsZSxcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5wbGF5bGlzdC5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICBjb3ZlclVybDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIHRyYWNrQ291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgdHJhY2tzOiBbXSxcclxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEucGxheWxpc3QuY3JlYXRlZEF0KSxcclxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGRhdGEucGxheWxpc3QudXBkYXRlZEF0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNldCh7IHBsYXlsaXN0czogW25ld1BsYXlsaXN0LCAuLi5wbGF5bGlzdHNdIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3UGxheWxpc3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBkZWxldGVQbGF5bGlzdDogYXN5bmMgKHBsYXlsaXN0SWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHBsYXlsaXN0cyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0KPQtNCw0LvRj9C10Lwg0LvQvtC60LDQu9GM0L3QvlxyXG4gICAgICAgIHNldCh7IHBsYXlsaXN0czogcGxheWxpc3RzLmZpbHRlcihwID0+IHAuaWQgIT09IHBsYXlsaXN0SWQpIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9wbGF5bGlzdHM/cGxheWxpc3RJZD0ke3BsYXlsaXN0SWR9YCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICB1cGRhdGVQbGF5bGlzdDogYXN5bmMgKHBsYXlsaXN0SWQsIGRhdGEpID0+IHtcclxuICAgICAgICBjb25zdCB7IHBsYXlsaXN0cyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0J7QsdC90L7QstC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICBjb25zdCB1cGRhdGVkUGxheWxpc3RzID0gcGxheWxpc3RzLm1hcChwID0+IHtcclxuICAgICAgICAgIGlmIChwLmlkID09PSBwbGF5bGlzdElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICB0aXRsZTogZGF0YS5uYW1lIHx8IHAudGl0bGUsXHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuZGVzY3JpcHRpb24gPz8gcC5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IHVwZGF0ZWRQbGF5bGlzdHMgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGZldGNoKGAvYXBpL3BsYXlsaXN0c2AsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBwbGF5bGlzdElkLCAuLi5kYXRhIH0pLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBhZGRUcmFja1RvUGxheWxpc3Q6IGFzeW5jIChwbGF5bGlzdElkLCB0cmFjaykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgcGxheWxpc3RzIH0gPSBnZXQoKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBwbGF5bGlzdCA9IHBsYXlsaXN0cy5maW5kKHAgPT4gcC5pZCA9PT0gcGxheWxpc3RJZCk7XHJcbiAgICAgICAgaWYgKCFwbGF5bGlzdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCf0YDQvtCy0LXRgNGP0LXQvCwg0L3QtSDQtNC+0LHQsNCy0LvQtdC9INC70Lgg0YPQttC1XHJcbiAgICAgICAgaWYgKHBsYXlsaXN0LnRyYWNrcy5zb21lKHQgPT4gdC5pZCA9PT0gdHJhY2suaWQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3BsYXlsaXN0cy90cmFja3MnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBwbGF5bGlzdElkLCB0cmFjayB9KSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgLy8g0J7QsdC90L7QstC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFBsYXlsaXN0cyA9IHBsYXlsaXN0cy5tYXAocCA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKHAuaWQgPT09IHBsYXlsaXN0SWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgICAgIHRyYWNrczogWy4uLnAudHJhY2tzLCB0cmFja10sXHJcbiAgICAgICAgICAgICAgICAgIHRyYWNrQ291bnQ6IHAudHJhY2tDb3VudCArIDEsXHJcbiAgICAgICAgICAgICAgICAgIGNvdmVyVXJsOiBwLmNvdmVyVXJsIHx8IHRyYWNrLmNvdmVyVXJsLFxyXG4gICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IHVwZGF0ZWRQbGF5bGlzdHMgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0cmFjayB0byBwbGF5bGlzdDonLCBlcnJvcik7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgcmVtb3ZlVHJhY2tGcm9tUGxheWxpc3Q6IGFzeW5jIChwbGF5bGlzdElkLCB0cmFja0lkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBwbGF5bGlzdHMgfSA9IGdldCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCj0LTQsNC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICBjb25zdCB1cGRhdGVkUGxheWxpc3RzID0gcGxheWxpc3RzLm1hcChwID0+IHtcclxuICAgICAgICAgIGlmIChwLmlkID09PSBwbGF5bGlzdElkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1RyYWNrcyA9IHAudHJhY2tzLmZpbHRlcih0ID0+IHQuaWQgIT09IHRyYWNrSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgdHJhY2tzOiBuZXdUcmFja3MsXHJcbiAgICAgICAgICAgICAgdHJhY2tDb3VudDogcC50cmFja0NvdW50IC0gMSxcclxuICAgICAgICAgICAgICBjb3ZlclVybDogbmV3VHJhY2tzWzBdPy5jb3ZlclVybCxcclxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IHVwZGF0ZWRQbGF5bGlzdHMgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGZldGNoKGAvYXBpL3BsYXlsaXN0cy90cmFja3M/cGxheWxpc3RJZD0ke3BsYXlsaXN0SWR9JnRyYWNrSWQ9JHt0cmFja0lkfWAsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyB0cmFjayBmcm9tIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBnZXRQbGF5bGlzdDogKHBsYXlsaXN0SWQpID0+IHtcclxuICAgICAgICByZXR1cm4gZ2V0KCkucGxheWxpc3RzLmZpbmQocCA9PiBwLmlkID09PSBwbGF5bGlzdElkKTtcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnY2l0cnVzLXVzZXItcGxheWxpc3RzJyxcclxuICAgICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIHBsYXlsaXN0czogc3RhdGUucGxheWxpc3RzLFxyXG4gICAgICAgIHVzZXJJZDogc3RhdGUudXNlcklkLFxyXG4gICAgICB9KSxcclxuICAgIH1cclxuICApXHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJwZXJzaXN0IiwiQ0FDSEVfVFRMIiwidXNlUGxheWxpc3RzU3RvcmUiLCJzZXQiLCJnZXQiLCJwbGF5bGlzdHMiLCJ2a1BsYXlsaXN0cyIsInVzZXJJZCIsImlzTG9hZGluZyIsImxhc3RGZXRjaGVkQXQiLCJ2a1BsYXlsaXN0c0xhc3RGZXRjaGVkQXQiLCJzZXRVc2VySWQiLCJjdXJyZW50VXNlcklkIiwibG9hZFBsYXlsaXN0cyIsImlzQ2FjaGVWYWxpZCIsIkRhdGUiLCJub3ciLCJpc1ZLUGxheWxpc3RzQ2FjaGVWYWxpZCIsImZvcmNlUmVmcmVzaCIsImxlbmd0aCIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwiZGF0YSIsImpzb24iLCJtYXAiLCJwIiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiY292ZXJVcmwiLCJ0cmFja3MiLCJ0cmFja0NvdW50IiwiX2NvdW50IiwidCIsInRyYWNrSWQiLCJhcnRpc3QiLCJkdXJhdGlvbiIsImF1ZGlvVXJsIiwic291cmNlIiwiaXNBdmFpbGFibGUiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJlcnJvciIsInNldFZLUGxheWxpc3RzIiwiZ2V0VktQbGF5bGlzdHMiLCJjcmVhdGVQbGF5bGlzdCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInBsYXlsaXN0IiwibmV3UGxheWxpc3QiLCJ1bmRlZmluZWQiLCJkZWxldGVQbGF5bGlzdCIsInBsYXlsaXN0SWQiLCJmaWx0ZXIiLCJ1cGRhdGVQbGF5bGlzdCIsInVwZGF0ZWRQbGF5bGlzdHMiLCJuYW1lIiwiYWRkVHJhY2tUb1BsYXlsaXN0IiwidHJhY2siLCJmaW5kIiwic29tZSIsIm9rIiwicmVtb3ZlVHJhY2tGcm9tUGxheWxpc3QiLCJuZXdUcmFja3MiLCJnZXRQbGF5bGlzdCIsInBhcnRpYWxpemUiLCJzdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/playlists.ts\n"));

/***/ })

});