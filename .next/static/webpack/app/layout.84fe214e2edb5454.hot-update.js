"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/store/favorites.ts":
/*!********************************!*\
  !*** ./src/store/favorites.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFavoritesStore: function() { return /* binding */ useFavoritesStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/**\r\n * Store для управления избранными треками\r\n * @module store/favorites\r\n */ \n\n// Время жизни кэша - 30 минут\nconst CACHE_TTL = 30 * 60 * 1000;\nconst useFavoritesStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        favorites: [],\n        actionsHistory: [],\n        unreadActionsCount: 0,\n        userId: null,\n        isLoading: false,\n        isInitialized: false,\n        lastFetchedAt: null,\n        isCacheValid: ()=>{\n            const { lastFetchedAt } = get();\n            if (!lastFetchedAt) return false;\n            return Date.now() - lastFetchedAt < CACHE_TTL;\n        },\n        setUserId: (userId)=>{\n            const { userId: currentUserId } = get();\n            // Только если пользователь изменился\n            if (currentUserId !== userId) {\n                set({\n                    userId\n                });\n                if (userId) {\n                    get().loadFavorites(true); // Принудительное обновление при смене пользователя\n                }\n            }\n        },\n        addToFavorites: async (track)=>{\n            const { userId, favorites, actionsHistory, unreadActionsCount } = get();\n            // Проверяем, не добавлен ли уже\n            if (favorites.some((f)=>f.id === track.id)) {\n                return;\n            }\n            const favoriteTrack = {\n                ...track,\n                addedAt: new Date()\n            };\n            // Добавляем в историю действий\n            const action = {\n                type: \"add\",\n                track,\n                timestamp: new Date()\n            };\n            // Добавляем локально (в начало списка)\n            set({\n                favorites: [\n                    favoriteTrack,\n                    ...favorites\n                ],\n                actionsHistory: [\n                    action,\n                    ...actionsHistory\n                ].slice(0, 100),\n                unreadActionsCount: unreadActionsCount + 1\n            });\n            // Синхронизируем с сервером если есть userId\n            if (userId) {\n                try {\n                    await fetch(\"/api/favorites\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            userId,\n                            track\n                        })\n                    });\n                } catch (error) {\n                    console.error(\"Error syncing favorite to server:\", error);\n                }\n            }\n        },\n        removeFromFavorites: async (trackId)=>{\n            const { userId, favorites, actionsHistory, unreadActionsCount } = get();\n            // Находим трек для истории\n            const track = favorites.find((f)=>f.id === trackId);\n            // Добавляем в историю действий\n            if (track) {\n                const action = {\n                    type: \"remove\",\n                    track,\n                    timestamp: new Date()\n                };\n                set({\n                    actionsHistory: [\n                        action,\n                        ...actionsHistory\n                    ].slice(0, 100),\n                    unreadActionsCount: unreadActionsCount + 1\n                });\n            }\n            // Удаляем локально\n            set({\n                favorites: favorites.filter((f)=>f.id !== trackId)\n            });\n            // Синхронизируем с сервером если есть userId\n            if (userId) {\n                try {\n                    await fetch(\"/api/favorites?userId=\".concat(userId, \"&trackId=\").concat(trackId), {\n                        method: \"DELETE\"\n                    });\n                } catch (error) {\n                    console.error(\"Error removing favorite from server:\", error);\n                }\n            }\n        },\n        isFavorite: (trackId)=>{\n            return get().favorites.some((f)=>f.id === trackId);\n        },\n        loadFavorites: async function() {\n            let forceRefresh = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            const { userId, isLoading, isCacheValid, favorites } = get();\n            if (!userId) return;\n            // Не загружаем повторно, если уже загружаем или кэш валиден\n            if (isLoading) return;\n            if (!forceRefresh && isCacheValid() && favorites.length > 0) {\n                console.log(\"[Favorites] Using cached data\");\n                return;\n            }\n            set({\n                isLoading: true\n            });\n            console.log(\"[Favorites] Loading from server...\");\n            try {\n                const response = await fetch(\"/api/favorites?userId=\".concat(userId));\n                const data = await response.json();\n                if (data.favorites && data.favorites.length > 0) {\n                    const favorites = data.favorites.map((f)=>({\n                            id: f.trackId,\n                            title: f.title,\n                            artist: f.artist,\n                            duration: f.duration,\n                            coverUrl: f.coverUrl,\n                            audioUrl: f.audioUrl,\n                            source: f.source,\n                            addedAt: new Date(f.addedAt),\n                            isAvailable: !!f.audioUrl\n                        }));\n                    set({\n                        favorites,\n                        isInitialized: true,\n                        lastFetchedAt: Date.now()\n                    });\n                } else {\n                    set({\n                        lastFetchedAt: Date.now()\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error loading favorites:\", error);\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        syncWithServer: async ()=>{\n            const { userId, favorites } = get();\n            if (!userId) return;\n            for (const track of favorites){\n                try {\n                    await fetch(\"/api/favorites\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            userId,\n                            track\n                        })\n                    });\n                } catch (error) {\n                    console.error(\"Error syncing favorite:\", error);\n                }\n            }\n        },\n        // Массовое добавление без дубликатов (для первоначальной загрузки VK)\n        bulkAddToFavorites: (tracks)=>{\n            const { favorites } = get();\n            const existingIds = new Set(favorites.map((f)=>f.id));\n            const newTracks = tracks.filter((t)=>!existingIds.has(t.id)).map((t)=>({\n                    ...t,\n                    addedAt: new Date()\n                }));\n            if (newTracks.length > 0) {\n                // Добавляем новые треки в конец (VK треки как база)\n                set({\n                    favorites: [\n                        ...favorites,\n                        ...newTracks\n                    ],\n                    isInitialized: true\n                });\n            } else {\n                set({\n                    isInitialized: true\n                });\n            }\n        },\n        setInitialized: (value)=>{\n            set({\n                isInitialized: value\n            });\n        },\n        clearFavorites: ()=>{\n            set({\n                favorites: [],\n                isInitialized: false\n            });\n        },\n        clearActionsHistory: ()=>{\n            set({\n                actionsHistory: [],\n                unreadActionsCount: 0\n            });\n        },\n        markHistoryAsRead: ()=>{\n            set({\n                unreadActionsCount: 0\n            });\n        }\n    }), {\n    name: \"citrus-favorites\",\n    partialize: (state)=>({\n            favorites: state.favorites,\n            actionsHistory: state.actionsHistory,\n            unreadActionsCount: state.unreadActionsCount,\n            userId: state.userId,\n            isInitialized: state.isInitialized,\n            lastFetchedAt: state.lastFetchedAt\n        })\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9mYXZvcml0ZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRWdDO0FBQ1k7QUE2QzdDLDhCQUE4QjtBQUM5QixNQUFNRSxZQUFZLEtBQUssS0FBSztBQUVyQixNQUFNQyxvQkFBb0JILCtDQUFNQSxHQUNyQ0MsMkRBQU9BLENBQ0wsQ0FBQ0csS0FBS0MsTUFBUztRQUNiQyxXQUFXLEVBQUU7UUFDYkMsZ0JBQWdCLEVBQUU7UUFDbEJDLG9CQUFvQjtRQUNwQkMsUUFBUTtRQUNSQyxXQUFXO1FBQ1hDLGVBQWU7UUFDZkMsZUFBZTtRQUVmQyxjQUFjO1lBQ1osTUFBTSxFQUFFRCxhQUFhLEVBQUUsR0FBR1A7WUFDMUIsSUFBSSxDQUFDTyxlQUFlLE9BQU87WUFDM0IsT0FBT0UsS0FBS0MsR0FBRyxLQUFLSCxnQkFBZ0JWO1FBQ3RDO1FBRUFjLFdBQVcsQ0FBQ1A7WUFDVixNQUFNLEVBQUVBLFFBQVFRLGFBQWEsRUFBRSxHQUFHWjtZQUNsQyxxQ0FBcUM7WUFDckMsSUFBSVksa0JBQWtCUixRQUFRO2dCQUM1QkwsSUFBSTtvQkFBRUs7Z0JBQU87Z0JBQ2IsSUFBSUEsUUFBUTtvQkFDVkosTUFBTWEsYUFBYSxDQUFDLE9BQU8sbURBQW1EO2dCQUNoRjtZQUNGO1FBQ0Y7UUFFQUMsZ0JBQWdCLE9BQU9DO1lBQ3JCLE1BQU0sRUFBRVgsTUFBTSxFQUFFSCxTQUFTLEVBQUVDLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR0g7WUFFbEUsZ0NBQWdDO1lBQ2hDLElBQUlDLFVBQVVlLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLSCxNQUFNRyxFQUFFLEdBQUc7Z0JBQzFDO1lBQ0Y7WUFFQSxNQUFNQyxnQkFBK0I7Z0JBQ25DLEdBQUdKLEtBQUs7Z0JBQ1JLLFNBQVMsSUFBSVg7WUFDZjtZQUVBLCtCQUErQjtZQUMvQixNQUFNWSxTQUF5QjtnQkFDN0JDLE1BQU07Z0JBQ05Q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QUNqQzBCLEdBQUcsQ0FBQ2MsQ0FBQUEsSUFBTTtvQkFDVCxHQUFHQSxDQUFDO29CQUNKdEMsU0FBUyxJQUFJWDtnQkFDZjtZQUVGLElBQUlnRCxVQUFVbEIsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hCLG9EQUFvRDtnQkFDcER4QyxJQUFJO29CQUNGRSxXQUFXOzJCQUFJQTsyQkFBY3dEO3FCQUFVO29CQUN2Q25ELGVBQWU7Z0JBQ2pCO1lBQ0YsT0FBTztnQkFDTFAsSUFBSTtvQkFBRU8sZUFBZTtnQkFBSztZQUM1QjtRQUNGO1FBRUFzRCxnQkFBZ0IsQ0FBQ0M7WUFDZjlELElBQUk7Z0JBQUVPLGVBQWV1RDtZQUFNO1FBQzdCO1FBRUFDLGdCQUFnQjtZQUNkL0QsSUFBSTtnQkFBRUUsV0FBVyxFQUFFO2dCQUFFSyxlQUFlO1lBQU07UUFDNUM7UUFFQXlELHFCQUFxQjtZQUNuQmhFLElBQUk7Z0JBQUVHLGdCQUFnQixFQUFFO2dCQUFFQyxvQkFBb0I7WUFBRTtRQUNsRDtRQUVBNkQsbUJBQW1CO1lBQ2pCakUsSUFBSTtnQkFBRUksb0JBQW9CO1lBQUU7UUFDOUI7SUFDRixJQUNBO0lBQ0U4RCxNQUFNO0lBQ05DLFlBQVksQ0FBQ0MsUUFBVztZQUN0QmxFLFdBQVdrRSxNQUFNbEUsU0FBUztZQUMxQkMsZ0JBQWdCaUUsTUFBTWpFLGNBQWM7WUFDcENDLG9CQUFvQmdFLE1BQU1oRSxrQkFBa0I7WUFDNUNDLFFBQVErRCxNQUFNL0QsTUFBTTtZQUNwQkUsZUFBZTZELE1BQU03RCxhQUFhO1lBQ2xDQyxlQUFlNEQsTUFBTTVELGFBQWE7UUFDcEM7QUFDRixJQUVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdG9yZS9mYXZvcml0ZXMudHM/NDAwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU3RvcmUg0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPINC40LfQsdGA0LDQvdC90YvQvNC4INGC0YDQtdC60LDQvNC4XHJcbiAqIEBtb2R1bGUgc3RvcmUvZmF2b3JpdGVzXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XHJcbmltcG9ydCB7IHBlcnNpc3QgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xyXG5pbXBvcnQgdHlwZSB7IFRyYWNrIH0gZnJvbSAnQC90eXBlcy9hdWRpbyc7XHJcblxyXG5pbnRlcmZhY2UgRmF2b3JpdGVUcmFjayBleHRlbmRzIFRyYWNrIHtcclxuICBhZGRlZEF0OiBEYXRlO1xyXG59XHJcblxyXG4vLyDQmNGB0YLQvtGA0LjRjyDQtNC10LnRgdGC0LLQuNC5INGBINC40LfQsdGA0LDQvdC90YvQvFxyXG5pbnRlcmZhY2UgRmF2b3JpdGVBY3Rpb24ge1xyXG4gIHR5cGU6ICdhZGQnIHwgJ3JlbW92ZSc7XHJcbiAgdHJhY2s6IFRyYWNrO1xyXG4gIHRpbWVzdGFtcDogRGF0ZTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEZhdm9yaXRlc1N0YXRlIHtcclxuICAvLyDQlNCw0L3QvdGL0LVcclxuICBmYXZvcml0ZXM6IEZhdm9yaXRlVHJhY2tbXTtcclxuICBhY3Rpb25zSGlzdG9yeTogRmF2b3JpdGVBY3Rpb25bXTtcclxuICB1bnJlYWRBY3Rpb25zQ291bnQ6IG51bWJlcjsgLy8g0JrQvtC70LjRh9C10YHRgtCy0L4g0L3QtdC/0YDQvtGH0LjRgtCw0L3QvdGL0YUg0LTQtdC50YHRgtCy0LjQuVxyXG4gIHVzZXJJZDogc3RyaW5nIHwgbnVsbDtcclxuICBpc0xvYWRpbmc6IGJvb2xlYW47XHJcbiAgaXNJbml0aWFsaXplZDogYm9vbGVhbjsgLy8g0KTQu9Cw0LMg0YHQuNC90YXRgNC+0L3QuNC30LDRhtC40Lgg0YEgVktcclxuICBsYXN0RmV0Y2hlZEF0OiBudW1iZXIgfCBudWxsOyAvLyDQktGA0LXQvNGPINC/0L7RgdC70LXQtNC90LXQuSDQt9Cw0LPRgNGD0LfQutC4INGBINGB0LXRgNCy0LXRgNCwXHJcbiAgXHJcbiAgLy8gQWN0aW9uc1xyXG4gIHNldFVzZXJJZDogKHVzZXJJZDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcclxuICBhZGRUb0Zhdm9yaXRlczogKHRyYWNrOiBUcmFjaykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICByZW1vdmVGcm9tRmF2b3JpdGVzOiAodHJhY2tJZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIGlzRmF2b3JpdGU6ICh0cmFja0lkOiBzdHJpbmcpID0+IGJvb2xlYW47XHJcbiAgbG9hZEZhdm9yaXRlczogKGZvcmNlUmVmcmVzaD86IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD47XHJcbiAgc3luY1dpdGhTZXJ2ZXI6ICgpID0+IFByb21pc2U8dm9pZD47XHJcbiAgXHJcbiAgLy8g0JzQsNGB0YHQvtCy0L7QtSDQtNC+0LHQsNCy0LvQtdC90LjQtSAo0LTQu9GPIFZLKVxyXG4gIGJ1bGtBZGRUb0Zhdm9yaXRlczogKHRyYWNrczogVHJhY2tbXSkgPT4gdm9pZDtcclxuICBzZXRJbml0aWFsaXplZDogKHZhbHVlOiBib29sZWFuKSA9PiB2b2lkO1xyXG4gIGNsZWFyRmF2b3JpdGVzOiAoKSA9PiB2b2lkO1xyXG4gIGNsZWFyQWN0aW9uc0hpc3Rvcnk6ICgpID0+IHZvaWQ7XHJcbiAgXHJcbiAgLy8g0J7RgtC80LXRgtC40YLRjCDQuNGB0YLQvtGA0LjRjiDQutCw0Log0L/RgNC+0YfQuNGC0LDQvdC90YPRjlxyXG4gIG1hcmtIaXN0b3J5QXNSZWFkOiAoKSA9PiB2b2lkO1xyXG4gIFxyXG4gIC8vINCf0YDQvtCy0LXRgNC60LAg0LrRjdGI0LBcclxuICBpc0NhY2hlVmFsaWQ6ICgpID0+IGJvb2xlYW47XHJcbn1cclxuXHJcbi8vINCS0YDQtdC80Y8g0LbQuNC30L3QuCDQutGN0YjQsCAtIDMwINC80LjQvdGD0YJcclxuY29uc3QgQ0FDSEVfVFRMID0gMzAgKiA2MCAqIDEwMDA7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlRmF2b3JpdGVzU3RvcmUgPSBjcmVhdGU8RmF2b3JpdGVzU3RhdGU+KCkoXHJcbiAgcGVyc2lzdChcclxuICAgIChzZXQsIGdldCkgPT4gKHtcclxuICAgICAgZmF2b3JpdGVzOiBbXSxcclxuICAgICAgYWN0aW9uc0hpc3Rvcnk6IFtdLFxyXG4gICAgICB1bnJlYWRBY3Rpb25zQ291bnQ6IDAsXHJcbiAgICAgIHVzZXJJZDogbnVsbCxcclxuICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcclxuICAgICAgaXNJbml0aWFsaXplZDogZmFsc2UsXHJcbiAgICAgIGxhc3RGZXRjaGVkQXQ6IG51bGwsXHJcbiAgICAgIFxyXG4gICAgICBpc0NhY2hlVmFsaWQ6ICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IGxhc3RGZXRjaGVkQXQgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghbGFzdEZldGNoZWRBdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gbGFzdEZldGNoZWRBdCA8IENBQ0hFX1RUTDtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIHNldFVzZXJJZDogKHVzZXJJZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlcklkOiBjdXJyZW50VXNlcklkIH0gPSBnZXQoKTtcclxuICAgICAgICAvLyDQotC+0LvRjNC60L4g0LXRgdC70Lgg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GMINC40LfQvNC10L3QuNC70YHRj1xyXG4gICAgICAgIGlmIChjdXJyZW50VXNlcklkICE9PSB1c2VySWQpIHtcclxuICAgICAgICAgIHNldCh7IHVzZXJJZCB9KTtcclxuICAgICAgICAgIGlmICh1c2VySWQpIHtcclxuICAgICAgICAgICAgZ2V0KCkubG9hZEZhdm9yaXRlcyh0cnVlKTsgLy8g0J/RgNC40L3Rg9C00LjRgtC10LvRjNC90L7QtSDQvtCx0L3QvtCy0LvQtdC90LjQtSDQv9GA0Lgg0YHQvNC10L3QtSDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBhZGRUb0Zhdm9yaXRlczogYXN5bmMgKHRyYWNrKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIGZhdm9yaXRlcywgYWN0aW9uc0hpc3RvcnksIHVucmVhZEFjdGlvbnNDb3VudCB9ID0gZ2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0J/RgNC+0LLQtdGA0Y/QtdC8LCDQvdC1INC00L7QsdCw0LLQu9C10L0g0LvQuCDRg9C20LVcclxuICAgICAgICBpZiAoZmF2b3JpdGVzLnNvbWUoZiA9PiBmLmlkID09PSB0cmFjay5pZCkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgZmF2b3JpdGVUcmFjazogRmF2b3JpdGVUcmFjayA9IHtcclxuICAgICAgICAgIC4uLnRyYWNrLFxyXG4gICAgICAgICAgYWRkZWRBdDogbmV3IERhdGUoKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCU0L7QsdCw0LLQu9GP0LXQvCDQsiDQuNGB0YLQvtGA0LjRjiDQtNC10LnRgdGC0LLQuNC5XHJcbiAgICAgICAgY29uc3QgYWN0aW9uOiBGYXZvcml0ZUFjdGlvbiA9IHtcclxuICAgICAgICAgIHR5cGU6ICdhZGQnLFxyXG4gICAgICAgICAgdHJhY2ssXHJcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LvQvtC60LDQu9GM0L3QviAo0LIg0L3QsNGH0LDQu9C+INGB0L/QuNGB0LrQsClcclxuICAgICAgICBzZXQoeyBcclxuICAgICAgICAgIGZhdm9yaXRlczogW2Zhdm9yaXRlVHJhY2ssIC4uLmZhdm9yaXRlc10sXHJcbiAgICAgICAgICBhY3Rpb25zSGlzdG9yeTogW2FjdGlvbiwgLi4uYWN0aW9uc0hpc3RvcnldLnNsaWNlKDAsIDEwMCksIC8vINCl0YDQsNC90LjQvCDQv9C+0YHQu9C10LTQvdC40LUgMTAwINC00LXQudGB0YLQstC40LlcclxuICAgICAgICAgIHVucmVhZEFjdGlvbnNDb3VudDogdW5yZWFkQWN0aW9uc0NvdW50ICsgMSwgLy8g0KPQstC10LvQuNGH0LjQstCw0LXQvCDRgdGH0LXRgtGH0LjQuiDQvdC10L/RgNC+0YfQuNGC0LDQvdC90YvRhVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCh0LjQvdGF0YDQvtC90LjQt9C40YDRg9C10Lwg0YEg0YHQtdGA0LLQtdGA0L7QvCDQtdGB0LvQuCDQtdGB0YLRjCB1c2VySWRcclxuICAgICAgICBpZiAodXNlcklkKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS9mYXZvcml0ZXMnLCB7XHJcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIHRyYWNrIH0pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN5bmNpbmcgZmF2b3JpdGUgdG8gc2VydmVyOicsIGVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICByZW1vdmVGcm9tRmF2b3JpdGVzOiBhc3luYyAodHJhY2tJZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCBmYXZvcml0ZXMsIGFjdGlvbnNIaXN0b3J5LCB1bnJlYWRBY3Rpb25zQ291bnQgfSA9IGdldCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCd0LDRhdC+0LTQuNC8INGC0YDQtdC6INC00LvRjyDQuNGB0YLQvtGA0LjQuFxyXG4gICAgICAgIGNvbnN0IHRyYWNrID0gZmF2b3JpdGVzLmZpbmQoZiA9PiBmLmlkID09PSB0cmFja0lkKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LIg0LjRgdGC0L7RgNC40Y4g0LTQtdC50YHRgtCy0LjQuVxyXG4gICAgICAgIGlmICh0cmFjaykge1xyXG4gICAgICAgICAgY29uc3QgYWN0aW9uOiBGYXZvcml0ZUFjdGlvbiA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZScsXHJcbiAgICAgICAgICAgIHRyYWNrLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgc2V0KHsgXHJcbiAgICAgICAgICAgIGFjdGlvbnNIaXN0b3J5OiBbYWN0aW9uLCAuLi5hY3Rpb25zSGlzdG9yeV0uc2xpY2UoMCwgMTAwKSxcclxuICAgICAgICAgICAgdW5yZWFkQWN0aW9uc0NvdW50OiB1bnJlYWRBY3Rpb25zQ291bnQgKyAxLCAvLyDQo9Cy0LXQu9C40YfQuNCy0LDQtdC8INGB0YfQtdGC0YfQuNC6INC90LXQv9GA0L7Rh9C40YLQsNC90L3Ri9GFXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0KPQtNCw0LvRj9C10Lwg0LvQvtC60LDQu9GM0L3QvlxyXG4gICAgICAgIHNldCh7IGZhdm9yaXRlczogZmF2b3JpdGVzLmZpbHRlcihmID0+IGYuaWQgIT09IHRyYWNrSWQpIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCh0LjQvdGF0YDQvtC90LjQt9C40YDRg9C10Lwg0YEg0YHQtdGA0LLQtdGA0L7QvCDQtdGB0LvQuCDQtdGB0YLRjCB1c2VySWRcclxuICAgICAgICBpZiAodXNlcklkKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9mYXZvcml0ZXM/dXNlcklkPSR7dXNlcklkfSZ0cmFja0lkPSR7dHJhY2tJZH1gLCB7XHJcbiAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBmYXZvcml0ZSBmcm9tIHNlcnZlcjonLCBlcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgaXNGYXZvcml0ZTogKHRyYWNrSWQpID0+IHtcclxuICAgICAgICByZXR1cm4gZ2V0KCkuZmF2b3JpdGVzLnNvbWUoZiA9PiBmLmlkID09PSB0cmFja0lkKTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGxvYWRGYXZvcml0ZXM6IGFzeW5jIChmb3JjZVJlZnJlc2ggPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCBpc0xvYWRpbmcsIGlzQ2FjaGVWYWxpZCwgZmF2b3JpdGVzIH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIXVzZXJJZCkgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCd0LUg0LfQsNCz0YDRg9C20LDQtdC8INC/0L7QstGC0L7RgNC90L4sINC10YHQu9C4INGD0LbQtSDQt9Cw0LPRgNGD0LbQsNC10Lwg0LjQu9C4INC60Y3RiCDQstCw0LvQuNC00LXQvVxyXG4gICAgICAgIGlmIChpc0xvYWRpbmcpIHJldHVybjtcclxuICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiBpc0NhY2hlVmFsaWQoKSAmJiBmYXZvcml0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coJ1tGYXZvcml0ZXNdIFVzaW5nIGNhY2hlZCBkYXRhJyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHNldCh7IGlzTG9hZGluZzogdHJ1ZSB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZygnW0Zhdm9yaXRlc10gTG9hZGluZyBmcm9tIHNlcnZlci4uLicpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2Zhdm9yaXRlcz91c2VySWQ9JHt1c2VySWR9YCk7XHJcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoZGF0YS5mYXZvcml0ZXMgJiYgZGF0YS5mYXZvcml0ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBmYXZvcml0ZXM6IEZhdm9yaXRlVHJhY2tbXSA9IGRhdGEuZmF2b3JpdGVzLm1hcCgoZjogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICAgIGlkOiBmLnRyYWNrSWQsXHJcbiAgICAgICAgICAgICAgdGl0bGU6IGYudGl0bGUsXHJcbiAgICAgICAgICAgICAgYXJ0aXN0OiBmLmFydGlzdCxcclxuICAgICAgICAgICAgICBkdXJhdGlvbjogZi5kdXJhdGlvbixcclxuICAgICAgICAgICAgICBjb3ZlclVybDogZi5jb3ZlclVybCxcclxuICAgICAgICAgICAgICBhdWRpb1VybDogZi5hdWRpb1VybCxcclxuICAgICAgICAgICAgICBzb3VyY2U6IGYuc291cmNlLFxyXG4gICAgICAgICAgICAgIGFkZGVkQXQ6IG5ldyBEYXRlKGYuYWRkZWRBdCksXHJcbiAgICAgICAgICAgICAgaXNBdmFpbGFibGU6ICEhZi5hdWRpb1VybCxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBzZXQoeyBmYXZvcml0ZXMsIGlzSW5pdGlhbGl6ZWQ6IHRydWUsIGxhc3RGZXRjaGVkQXQ6IERhdGUubm93KCkgfSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzZXQoeyBsYXN0RmV0Y2hlZEF0OiBEYXRlLm5vdygpIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGZhdm9yaXRlczonLCBlcnJvcik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHNldCh7IGlzTG9hZGluZzogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgc3luY1dpdGhTZXJ2ZXI6IGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZCwgZmF2b3JpdGVzIH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIXVzZXJJZCkgcmV0dXJuO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgZmF2b3JpdGVzKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBhd2FpdCBmZXRjaCgnL2FwaS9mYXZvcml0ZXMnLCB7XHJcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB1c2VySWQsIHRyYWNrIH0pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN5bmNpbmcgZmF2b3JpdGU6JywgZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIC8vINCc0LDRgdGB0L7QstC+0LUg0LTQvtCx0LDQstC70LXQvdC40LUg0LHQtdC3INC00YPQsdC70LjQutCw0YLQvtCyICjQtNC70Y8g0L/QtdGA0LLQvtC90LDRh9Cw0LvRjNC90L7QuSDQt9Cw0LPRgNGD0LfQutC4IFZLKVxyXG4gICAgICBidWxrQWRkVG9GYXZvcml0ZXM6ICh0cmFja3MpID0+IHtcclxuICAgICAgICBjb25zdCB7IGZhdm9yaXRlcyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KGZhdm9yaXRlcy5tYXAoZiA9PiBmLmlkKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgbmV3VHJhY2tzOiBGYXZvcml0ZVRyYWNrW10gPSB0cmFja3NcclxuICAgICAgICAgIC5maWx0ZXIodCA9PiAhZXhpc3RpbmdJZHMuaGFzKHQuaWQpKVxyXG4gICAgICAgICAgLm1hcCh0ID0+ICh7XHJcbiAgICAgICAgICAgIC4uLnQsXHJcbiAgICAgICAgICAgIGFkZGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICB9KSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKG5ld1RyYWNrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0L3QvtCy0YvQtSDRgtGA0LXQutC4INCyINC60L7QvdC10YYgKFZLINGC0YDQtdC60Lgg0LrQsNC6INCx0LDQt9CwKVxyXG4gICAgICAgICAgc2V0KHsgXHJcbiAgICAgICAgICAgIGZhdm9yaXRlczogWy4uLmZhdm9yaXRlcywgLi4ubmV3VHJhY2tzXSxcclxuICAgICAgICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzZXQoeyBpc0luaXRpYWxpemVkOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIHNldEluaXRpYWxpemVkOiAodmFsdWUpID0+IHtcclxuICAgICAgICBzZXQoeyBpc0luaXRpYWxpemVkOiB2YWx1ZSB9KTtcclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGNsZWFyRmF2b3JpdGVzOiAoKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgZmF2b3JpdGVzOiBbXSwgaXNJbml0aWFsaXplZDogZmFsc2UgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBjbGVhckFjdGlvbnNIaXN0b3J5OiAoKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgYWN0aW9uc0hpc3Rvcnk6IFtdLCB1bnJlYWRBY3Rpb25zQ291bnQ6IDAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBtYXJrSGlzdG9yeUFzUmVhZDogKCkgPT4ge1xyXG4gICAgICAgIHNldCh7IHVucmVhZEFjdGlvbnNDb3VudDogMCB9KTtcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnY2l0cnVzLWZhdm9yaXRlcycsXHJcbiAgICAgIHBhcnRpYWxpemU6IChzdGF0ZSkgPT4gKHtcclxuICAgICAgICBmYXZvcml0ZXM6IHN0YXRlLmZhdm9yaXRlcyxcclxuICAgICAgICBhY3Rpb25zSGlzdG9yeTogc3RhdGUuYWN0aW9uc0hpc3RvcnksXHJcbiAgICAgICAgdW5yZWFkQWN0aW9uc0NvdW50OiBzdGF0ZS51bnJlYWRBY3Rpb25zQ291bnQsXHJcbiAgICAgICAgdXNlcklkOiBzdGF0ZS51c2VySWQsXHJcbiAgICAgICAgaXNJbml0aWFsaXplZDogc3RhdGUuaXNJbml0aWFsaXplZCxcclxuICAgICAgICBsYXN0RmV0Y2hlZEF0OiBzdGF0ZS5sYXN0RmV0Y2hlZEF0LFxyXG4gICAgICB9KSxcclxuICAgIH1cclxuICApXHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJwZXJzaXN0IiwiQ0FDSEVfVFRMIiwidXNlRmF2b3JpdGVzU3RvcmUiLCJzZXQiLCJnZXQiLCJmYXZvcml0ZXMiLCJhY3Rpb25zSGlzdG9yeSIsInVucmVhZEFjdGlvbnNDb3VudCIsInVzZXJJZCIsImlzTG9hZGluZyIsImlzSW5pdGlhbGl6ZWQiLCJsYXN0RmV0Y2hlZEF0IiwiaXNDYWNoZVZhbGlkIiwiRGF0ZSIsIm5vdyIsInNldFVzZXJJZCIsImN1cnJlbnRVc2VySWQiLCJsb2FkRmF2b3JpdGVzIiwiYWRkVG9GYXZvcml0ZXMiLCJ0cmFjayIsInNvbWUiLCJmIiwiaWQiLCJmYXZvcml0ZVRyYWNrIiwiYWRkZWRBdCIsImFjdGlvbiIsInR5cGUiLCJ0aW1lc3RhbXAiLCJzbGljZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZXJyb3IiLCJjb25zb2xlIiwicmVtb3ZlRnJvbUZhdm9yaXRlcyIsInRyYWNrSWQiLCJmaW5kIiwiZmlsdGVyIiwiaXNGYXZvcml0ZSIsImZvcmNlUmVmcmVzaCIsImxlbmd0aCIsImxvZyIsInJlc3BvbnNlIiwiZGF0YSIsImpzb24iLCJtYXAiLCJ0aXRsZSIsImFydGlzdCIsImR1cmF0aW9uIiwiY292ZXJVcmwiLCJhdWRpb1VybCIsInNvdXJjZSIsImlzQXZhaWxhYmxlIiwic3luY1dpdGhTZXJ2ZXIiLCJidWxrQWRkVG9GYXZvcml0ZXMiLCJ0cmFja3MiLCJleGlzdGluZ0lkcyIsIlNldCIsIm5ld1RyYWNrcyIsInQiLCJoYXMiLCJzZXRJbml0aWFsaXplZCIsInZhbHVlIiwiY2xlYXJGYXZvcml0ZXMiLCJjbGVhckFjdGlvbnNIaXN0b3J5IiwibWFya0hpc3RvcnlBc1JlYWQiLCJuYW1lIiwicGFydGlhbGl6ZSIsInN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/favorites.ts\n"));

/***/ })

});