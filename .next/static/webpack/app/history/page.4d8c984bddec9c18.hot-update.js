"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/history/page",{

/***/ "(app-pages-browser)/./src/store/playlists.ts":
/*!********************************!*\
  !*** ./src/store/playlists.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   usePlaylistsStore: function() { return /* binding */ usePlaylistsStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/**\r\n * Store для управления пользовательскими плейлистами\r\n * @module store/playlists\r\n */ \n\nconst usePlaylistsStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        playlists: [],\n        userId: null,\n        isLoading: false,\n        setUserId: (userId)=>{\n            set({\n                userId\n            });\n            if (userId) {\n                get().loadPlaylists();\n            }\n        },\n        loadPlaylists: async ()=>{\n            const { userId } = get();\n            if (!userId) return;\n            set({\n                isLoading: true\n            });\n            try {\n                const response = await fetch(\"/api/playlists?userId=\".concat(userId));\n                const data = await response.json();\n                if (data.playlists) {\n                    const playlists = data.playlists.map((p)=>{\n                        var _p_tracks_, _p_tracks, _p__count, _p_tracks1;\n                        return {\n                            id: p.id,\n                            title: p.title,\n                            description: p.description,\n                            coverUrl: p.coverUrl || ((_p_tracks = p.tracks) === null || _p_tracks === void 0 ? void 0 : (_p_tracks_ = _p_tracks[0]) === null || _p_tracks_ === void 0 ? void 0 : _p_tracks_.coverUrl),\n                            trackCount: ((_p__count = p._count) === null || _p__count === void 0 ? void 0 : _p__count.tracks) || ((_p_tracks1 = p.tracks) === null || _p_tracks1 === void 0 ? void 0 : _p_tracks1.length) || 0,\n                            tracks: (p.tracks || []).map((t)=>({\n                                    id: t.trackId,\n                                    title: t.title,\n                                    artist: t.artist,\n                                    duration: t.duration,\n                                    coverUrl: t.coverUrl,\n                                    audioUrl: t.audioUrl,\n                                    source: t.source,\n                                    isAvailable: !!t.audioUrl\n                                })),\n                            createdAt: new Date(p.createdAt),\n                            updatedAt: new Date(p.updatedAt)\n                        };\n                    });\n                    set({\n                        playlists\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error loading playlists:\", error);\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        createPlaylist: async (title, description)=>{\n            const { userId, playlists } = get();\n            if (!userId) return null;\n            try {\n                const response = await fetch(\"/api/playlists\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        userId,\n                        title,\n                        description\n                    })\n                });\n                const data = await response.json();\n                if (data.playlist) {\n                    const newPlaylist = {\n                        id: data.playlist.id,\n                        title: data.playlist.title,\n                        description: data.playlist.description,\n                        coverUrl: undefined,\n                        trackCount: 0,\n                        tracks: [],\n                        createdAt: new Date(data.playlist.createdAt),\n                        updatedAt: new Date(data.playlist.updatedAt)\n                    };\n                    set({\n                        playlists: [\n                            newPlaylist,\n                            ...playlists\n                        ]\n                    });\n                    return newPlaylist;\n                }\n            } catch (error) {\n                console.error(\"Error creating playlist:\", error);\n            }\n            return null;\n        },\n        deletePlaylist: async (playlistId)=>{\n            const { playlists } = get();\n            // Удаляем локально\n            set({\n                playlists: playlists.filter((p)=>p.id !== playlistId)\n            });\n            try {\n                await fetch(\"/api/playlists?playlistId=\".concat(playlistId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error deleting playlist:\", error);\n            }\n        },\n        updatePlaylist: async (playlistId, data)=>{\n            const { playlists } = get();\n            // Обновляем локально\n            const updatedPlaylists = playlists.map((p)=>{\n                if (p.id === playlistId) {\n                    var _data_description;\n                    return {\n                        ...p,\n                        title: data.name || p.title,\n                        description: (_data_description = data.description) !== null && _data_description !== void 0 ? _data_description : p.description,\n                        updatedAt: new Date()\n                    };\n                }\n                return p;\n            });\n            set({\n                playlists: updatedPlaylists\n            });\n            try {\n                await fetch(\"/api/playlists\", {\n                    method: \"PATCH\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        playlistId,\n                        ...data\n                    })\n                });\n            } catch (error) {\n                console.error(\"Error updating playlist:\", error);\n            }\n        },\n        addTrackToPlaylist: async (playlistId, track)=>{\n            const { playlists } = get();\n            const playlist = playlists.find((p)=>p.id === playlistId);\n            if (!playlist) return false;\n            // Проверяем, не добавлен ли уже\n            if (playlist.tracks.some((t)=>t.id === track.id)) {\n                return false;\n            }\n            try {\n                const response = await fetch(\"/api/playlists/tracks\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        playlistId,\n                        track\n                    })\n                });\n                if (response.ok) {\n                    // Обновляем локально\n                    const updatedPlaylists = playlists.map((p)=>{\n                        if (p.id === playlistId) {\n                            return {\n                                ...p,\n                                tracks: [\n                                    ...p.tracks,\n                                    track\n                                ],\n                                trackCount: p.trackCount + 1,\n                                coverUrl: p.coverUrl || track.coverUrl,\n                                updatedAt: new Date()\n                            };\n                        }\n                        return p;\n                    });\n                    set({\n                        playlists: updatedPlaylists\n                    });\n                    return true;\n                }\n                return false;\n            } catch (error) {\n                console.error(\"Error adding track to playlist:\", error);\n                return false;\n            }\n        },\n        removeTrackFromPlaylist: async (playlistId, trackId)=>{\n            const { playlists } = get();\n            // Удаляем локально\n            const updatedPlaylists = playlists.map((p)=>{\n                if (p.id === playlistId) {\n                    var _newTracks_;\n                    const newTracks = p.tracks.filter((t)=>t.id !== trackId);\n                    return {\n                        ...p,\n                        tracks: newTracks,\n                        trackCount: p.trackCount - 1,\n                        coverUrl: (_newTracks_ = newTracks[0]) === null || _newTracks_ === void 0 ? void 0 : _newTracks_.coverUrl,\n                        updatedAt: new Date()\n                    };\n                }\n                return p;\n            });\n            set({\n                playlists: updatedPlaylists\n            });\n            try {\n                await fetch(\"/api/playlists/tracks?playlistId=\".concat(playlistId, \"&trackId=\").concat(trackId), {\n                    method: \"DELETE\"\n                });\n            } catch (error) {\n                console.error(\"Error removing track from playlist:\", error);\n            }\n        },\n        getPlaylist: (playlistId)=>{\n            return get().playlists.find((p)=>p.id === playlistId);\n        }\n    }), {\n    name: \"citrus-user-playlists\",\n    partialize: (state)=>({\n            playlists: state.playlists,\n            userId: state.userId\n        })\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9wbGF5bGlzdHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRWdDO0FBQ1k7QUErQnRDLE1BQU1FLG9CQUFvQkYsK0NBQU1BLEdBQ3JDQywyREFBT0EsQ0FDTCxDQUFDRSxLQUFLQyxNQUFTO1FBQ2JDLFdBQVcsRUFBRTtRQUNiQyxRQUFRO1FBQ1JDLFdBQVc7UUFFWEMsV0FBVyxDQUFDRjtZQUNWSCxJQUFJO2dCQUFFRztZQUFPO1lBQ2IsSUFBSUEsUUFBUTtnQkFDVkYsTUFBTUssYUFBYTtZQUNyQjtRQUNGO1FBRUFBLGVBQWU7WUFDYixNQUFNLEVBQUVILE1BQU0sRUFBRSxHQUFHRjtZQUNuQixJQUFJLENBQUNFLFFBQVE7WUFFYkgsSUFBSTtnQkFBRUksV0FBVztZQUFLO1lBRXRCLElBQUk7Z0JBQ0YsTUFBTUcsV0FBVyxNQUFNQyxNQUFNLHlCQUFnQyxPQUFQTDtnQkFDdEQsTUFBTU0sT0FBTyxNQUFNRixTQUFTRyxJQUFJO2dCQUVoQyxJQUFJRCxLQUFLUCxTQUFTLEVBQUU7b0JBQ2xCLE1BQU1BLFlBQTRCTyxLQUFLUCxTQUFTLENBQUNTLEdBQUcsQ0FBQyxDQUFDQzs0QkFJNUJBLFlBQUFBLFdBQ1pBLFdBQW9CQTsrQkFMZ0M7NEJBQ2hFQyxJQUFJRCxFQUFFQyxFQUFFOzRCQUNSQyxPQUFPRixFQUFFRSxLQUFLOzRCQUNkQyxhQUFhSCxFQUFFRyxXQUFXOzRCQUMxQkMsVUFBVUosRUFBRUksUUFBUSxNQUFJSixZQUFBQSxFQUFFSyxNQUFNLGNBQVJMLGlDQUFBQSxhQUFBQSxTQUFVLENBQUMsRUFBRSxjQUFiQSxpQ0FBQUEsV0FBZUksUUFBUTs0QkFDL0NFLFlBQVlOLEVBQUFBLFlBQUFBLEVBQUVPLE1BQU0sY0FBUlAsZ0NBQUFBLFVBQVVLLE1BQU0sT0FBSUwsYUFBQUEsRUFBRUssTUFBTSxjQUFSTCxpQ0FBQUEsV0FBVVEsTUFBTSxLQUFJOzRCQUNwREgsUUFBUSxDQUFD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Q0Y7UUFFQXdCLGFBQWEsQ0FBQ1o7WUFDWixPQUFPMUMsTUFBTUMsU0FBUyxDQUFDZ0QsSUFBSSxDQUFDdEMsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLOEI7UUFDNUM7SUFDRixJQUNBO0lBQ0VJLE1BQU07SUFDTlMsWUFBWSxDQUFDQyxRQUFXO1lBQ3RCdkQsV0FBV3VELE1BQU12RCxTQUFTO1lBQzFCQyxRQUFRc0QsTUFBTXRELE1BQU07UUFDdEI7QUFDRixJQUVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdG9yZS9wbGF5bGlzdHMudHM/MGZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogU3RvcmUg0LTQu9GPINGD0L/RgNCw0LLQu9C10L3QuNGPINC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjNGB0LrQuNC80Lgg0L/Qu9C10LnQu9C40YHRgtCw0LzQuFxyXG4gKiBAbW9kdWxlIHN0b3JlL3BsYXlsaXN0c1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xyXG5pbXBvcnQgeyBwZXJzaXN0IH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcclxuaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJ0AvdHlwZXMvYXVkaW8nO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VyUGxheWxpc3Qge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZztcclxuICBjb3ZlclVybD86IHN0cmluZztcclxuICB0cmFja0NvdW50OiBudW1iZXI7XHJcbiAgdHJhY2tzOiBUcmFja1tdO1xyXG4gIGNyZWF0ZWRBdDogRGF0ZTtcclxuICB1cGRhdGVkQXQ6IERhdGU7XHJcbn1cclxuXHJcbmludGVyZmFjZSBQbGF5bGlzdHNTdGF0ZSB7XHJcbiAgLy8g0JTQsNC90L3Ri9C1XHJcbiAgcGxheWxpc3RzOiBVc2VyUGxheWxpc3RbXTtcclxuICB1c2VySWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIFxyXG4gIC8vIEFjdGlvbnNcclxuICBzZXRVc2VySWQ6ICh1c2VySWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XHJcbiAgbG9hZFBsYXlsaXN0czogKCkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBjcmVhdGVQbGF5bGlzdDogKHRpdGxlOiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nKSA9PiBQcm9taXNlPFVzZXJQbGF5bGlzdCB8IG51bGw+O1xyXG4gIGRlbGV0ZVBsYXlsaXN0OiAocGxheWxpc3RJZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHVwZGF0ZVBsYXlsaXN0OiAocGxheWxpc3RJZDogc3RyaW5nLCBkYXRhOiB7IG5hbWU/OiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH0pID0+IFByb21pc2U8dm9pZD47XHJcbiAgYWRkVHJhY2tUb1BsYXlsaXN0OiAocGxheWxpc3RJZDogc3RyaW5nLCB0cmFjazogVHJhY2spID0+IFByb21pc2U8Ym9vbGVhbj47XHJcbiAgcmVtb3ZlVHJhY2tGcm9tUGxheWxpc3Q6IChwbGF5bGlzdElkOiBzdHJpbmcsIHRyYWNrSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBnZXRQbGF5bGlzdDogKHBsYXlsaXN0SWQ6IHN0cmluZykgPT4gVXNlclBsYXlsaXN0IHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgdXNlUGxheWxpc3RzU3RvcmUgPSBjcmVhdGU8UGxheWxpc3RzU3RhdGU+KCkoXHJcbiAgcGVyc2lzdChcclxuICAgIChzZXQsIGdldCkgPT4gKHtcclxuICAgICAgcGxheWxpc3RzOiBbXSxcclxuICAgICAgdXNlcklkOiBudWxsLFxyXG4gICAgICBpc0xvYWRpbmc6IGZhbHNlLFxyXG4gICAgICBcclxuICAgICAgc2V0VXNlcklkOiAodXNlcklkKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgdXNlcklkIH0pO1xyXG4gICAgICAgIGlmICh1c2VySWQpIHtcclxuICAgICAgICAgIGdldCgpLmxvYWRQbGF5bGlzdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBsb2FkUGxheWxpc3RzOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQgfSA9IGdldCgpO1xyXG4gICAgICAgIGlmICghdXNlcklkKSByZXR1cm47XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2V0KHsgaXNMb2FkaW5nOiB0cnVlIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL3BsYXlsaXN0cz91c2VySWQ9JHt1c2VySWR9YCk7XHJcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoZGF0YS5wbGF5bGlzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcGxheWxpc3RzOiBVc2VyUGxheWxpc3RbXSA9IGRhdGEucGxheWxpc3RzLm1hcCgocDogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICAgIGlkOiBwLmlkLFxyXG4gICAgICAgICAgICAgIHRpdGxlOiBwLnRpdGxlLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBwLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgIGNvdmVyVXJsOiBwLmNvdmVyVXJsIHx8IHAudHJhY2tzPy5bMF0/LmNvdmVyVXJsLFxyXG4gICAgICAgICAgICAgIHRyYWNrQ291bnQ6IHAuX2NvdW50Py50cmFja3MgfHwgcC50cmFja3M/Lmxlbmd0aCB8fCAwLFxyXG4gICAgICAgICAgICAgIHRyYWNrczogKHAudHJhY2tzIHx8IFtdKS5tYXAoKHQ6IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgICAgIGlkOiB0LnRyYWNrSWQsXHJcbiAgICAgICAgICAgICAgICB0aXRsZTogdC50aXRsZSxcclxuICAgICAgICAgICAgICAgIGFydGlzdDogdC5hcnRpc3QsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdC5kdXJhdGlvbixcclxuICAgICAgICAgICAgICAgIGNvdmVyVXJsOiB0LmNvdmVyVXJsLFxyXG4gICAgICAgICAgICAgICAgYXVkaW9Vcmw6IHQuYXVkaW9VcmwsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHQuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgaXNBdmFpbGFibGU6ICEhdC5hdWRpb1VybCxcclxuICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShwLmNyZWF0ZWRBdCksXHJcbiAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShwLnVwZGF0ZWRBdCksXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgc2V0KHsgcGxheWxpc3RzIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHBsYXlsaXN0czonLCBlcnJvcik7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHNldCh7IGlzTG9hZGluZzogZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgY3JlYXRlUGxheWxpc3Q6IGFzeW5jICh0aXRsZSwgZGVzY3JpcHRpb24pID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZCwgcGxheWxpc3RzIH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIXVzZXJJZCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcGxheWxpc3RzJywge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXHJcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCB0aXRsZSwgZGVzY3JpcHRpb24gfSksXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGRhdGEucGxheWxpc3QpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3UGxheWxpc3Q6IFVzZXJQbGF5bGlzdCA9IHtcclxuICAgICAgICAgICAgICBpZDogZGF0YS5wbGF5bGlzdC5pZCxcclxuICAgICAgICAgICAgICB0aXRsZTogZGF0YS5wbGF5bGlzdC50aXRsZSxcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5wbGF5bGlzdC5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICBjb3ZlclVybDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgIHRyYWNrQ291bnQ6IDAsXHJcbiAgICAgICAgICAgICAgdHJhY2tzOiBbXSxcclxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGRhdGEucGxheWxpc3QuY3JlYXRlZEF0KSxcclxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKGRhdGEucGxheWxpc3QudXBkYXRlZEF0KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHNldCh7IHBsYXlsaXN0czogW25ld1BsYXlsaXN0LCAuLi5wbGF5bGlzdHNdIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3UGxheWxpc3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBkZWxldGVQbGF5bGlzdDogYXN5bmMgKHBsYXlsaXN0SWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHBsYXlsaXN0cyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0KPQtNCw0LvRj9C10Lwg0LvQvtC60LDQu9GM0L3QvlxyXG4gICAgICAgIHNldCh7IHBsYXlsaXN0czogcGxheWxpc3RzLmZpbHRlcihwID0+IHAuaWQgIT09IHBsYXlsaXN0SWQpIH0pO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBhd2FpdCBmZXRjaChgL2FwaS9wbGF5bGlzdHM/cGxheWxpc3RJZD0ke3BsYXlsaXN0SWR9YCwge1xyXG4gICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICB1cGRhdGVQbGF5bGlzdDogYXN5bmMgKHBsYXlsaXN0SWQsIGRhdGEpID0+IHtcclxuICAgICAgICBjb25zdCB7IHBsYXlsaXN0cyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0J7QsdC90L7QstC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICBjb25zdCB1cGRhdGVkUGxheWxpc3RzID0gcGxheWxpc3RzLm1hcChwID0+IHtcclxuICAgICAgICAgIGlmIChwLmlkID09PSBwbGF5bGlzdElkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgLi4ucCxcclxuICAgICAgICAgICAgICB0aXRsZTogZGF0YS5uYW1lIHx8IHAudGl0bGUsXHJcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRhdGEuZGVzY3JpcHRpb24gPz8gcC5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IHVwZGF0ZWRQbGF5bGlzdHMgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGZldGNoKGAvYXBpL3BsYXlsaXN0c2AsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBwbGF5bGlzdElkLCAuLi5kYXRhIH0pLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBhZGRUcmFja1RvUGxheWxpc3Q6IGFzeW5jIChwbGF5bGlzdElkLCB0cmFjaykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgcGxheWxpc3RzIH0gPSBnZXQoKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBwbGF5bGlzdCA9IHBsYXlsaXN0cy5maW5kKHAgPT4gcC5pZCA9PT0gcGxheWxpc3RJZCk7XHJcbiAgICAgICAgaWYgKCFwbGF5bGlzdCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCf0YDQvtCy0LXRgNGP0LXQvCwg0L3QtSDQtNC+0LHQsNCy0LvQtdC9INC70Lgg0YPQttC1XHJcbiAgICAgICAgaWYgKHBsYXlsaXN0LnRyYWNrcy5zb21lKHQgPT4gdC5pZCA9PT0gdHJhY2suaWQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3BsYXlsaXN0cy90cmFja3MnLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBwbGF5bGlzdElkLCB0cmFjayB9KSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgICAgICAgLy8g0J7QsdC90L7QstC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFBsYXlsaXN0cyA9IHBsYXlsaXN0cy5tYXAocCA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKHAuaWQgPT09IHBsYXlsaXN0SWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgICAgIHRyYWNrczogWy4uLnAudHJhY2tzLCB0cmFja10sXHJcbiAgICAgICAgICAgICAgICAgIHRyYWNrQ291bnQ6IHAudHJhY2tDb3VudCArIDEsXHJcbiAgICAgICAgICAgICAgICAgIGNvdmVyVXJsOiBwLmNvdmVyVXJsIHx8IHRyYWNrLmNvdmVyVXJsLFxyXG4gICAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IHVwZGF0ZWRQbGF5bGlzdHMgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyB0cmFjayB0byBwbGF5bGlzdDonLCBlcnJvcik7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgcmVtb3ZlVHJhY2tGcm9tUGxheWxpc3Q6IGFzeW5jIChwbGF5bGlzdElkLCB0cmFja0lkKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBwbGF5bGlzdHMgfSA9IGdldCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCj0LTQsNC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICBjb25zdCB1cGRhdGVkUGxheWxpc3RzID0gcGxheWxpc3RzLm1hcChwID0+IHtcclxuICAgICAgICAgIGlmIChwLmlkID09PSBwbGF5bGlzdElkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1RyYWNrcyA9IHAudHJhY2tzLmZpbHRlcih0ID0+IHQuaWQgIT09IHRyYWNrSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgIC4uLnAsXHJcbiAgICAgICAgICAgICAgdHJhY2tzOiBuZXdUcmFja3MsXHJcbiAgICAgICAgICAgICAgdHJhY2tDb3VudDogcC50cmFja0NvdW50IC0gMSxcclxuICAgICAgICAgICAgICBjb3ZlclVybDogbmV3VHJhY2tzWzBdPy5jb3ZlclVybCxcclxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICBzZXQoeyBwbGF5bGlzdHM6IHVwZGF0ZWRQbGF5bGlzdHMgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGF3YWl0IGZldGNoKGAvYXBpL3BsYXlsaXN0cy90cmFja3M/cGxheWxpc3RJZD0ke3BsYXlsaXN0SWR9JnRyYWNrSWQ9JHt0cmFja0lkfWAsIHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyB0cmFjayBmcm9tIHBsYXlsaXN0OicsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBnZXRQbGF5bGlzdDogKHBsYXlsaXN0SWQpID0+IHtcclxuICAgICAgICByZXR1cm4gZ2V0KCkucGxheWxpc3RzLmZpbmQocCA9PiBwLmlkID09PSBwbGF5bGlzdElkKTtcclxuICAgICAgfSxcclxuICAgIH0pLFxyXG4gICAge1xyXG4gICAgICBuYW1lOiAnY2l0cnVzLXVzZXItcGxheWxpc3RzJyxcclxuICAgICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiAoe1xyXG4gICAgICAgIHBsYXlsaXN0czogc3RhdGUucGxheWxpc3RzLFxyXG4gICAgICAgIHVzZXJJZDogc3RhdGUudXNlcklkLFxyXG4gICAgICB9KSxcclxuICAgIH1cclxuICApXHJcbik7XHJcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJwZXJzaXN0IiwidXNlUGxheWxpc3RzU3RvcmUiLCJzZXQiLCJnZXQiLCJwbGF5bGlzdHMiLCJ1c2VySWQiLCJpc0xvYWRpbmciLCJzZXRVc2VySWQiLCJsb2FkUGxheWxpc3RzIiwicmVzcG9uc2UiLCJmZXRjaCIsImRhdGEiLCJqc29uIiwibWFwIiwicCIsImlkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImNvdmVyVXJsIiwidHJhY2tzIiwidHJhY2tDb3VudCIsIl9jb3VudCIsImxlbmd0aCIsInQiLCJ0cmFja0lkIiwiYXJ0aXN0IiwiZHVyYXRpb24iLCJhdWRpb1VybCIsInNvdXJjZSIsImlzQXZhaWxhYmxlIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInVwZGF0ZWRBdCIsImVycm9yIiwiY29uc29sZSIsImNyZWF0ZVBsYXlsaXN0IiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicGxheWxpc3QiLCJuZXdQbGF5bGlzdCIsInVuZGVmaW5lZCIsImRlbGV0ZVBsYXlsaXN0IiwicGxheWxpc3RJZCIsImZpbHRlciIsInVwZGF0ZVBsYXlsaXN0IiwidXBkYXRlZFBsYXlsaXN0cyIsIm5hbWUiLCJhZGRUcmFja1RvUGxheWxpc3QiLCJ0cmFjayIsImZpbmQiLCJzb21lIiwib2siLCJyZW1vdmVUcmFja0Zyb21QbGF5bGlzdCIsIm5ld1RyYWNrcyIsImdldFBsYXlsaXN0IiwicGFydGlhbGl6ZSIsInN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/playlists.ts\n"));

/***/ })

});