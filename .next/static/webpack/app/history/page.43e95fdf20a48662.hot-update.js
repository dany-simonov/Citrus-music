"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/history/page",{

/***/ "(app-pages-browser)/./src/store/favorites.ts":
/*!********************************!*\
  !*** ./src/store/favorites.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFavoritesStore: function() { return /* binding */ useFavoritesStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n/**\r\n * Store для управления избранными треками\r\n * @module store/favorites\r\n */ \n\n// Время жизни кэша - 30 минут\nconst CACHE_TTL = 30 * 60 * 1000;\nconst useFavoritesStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        favorites: [],\n        actionsHistory: [],\n        unreadActionsCount: 0,\n        userId: null,\n        isLoading: false,\n        isInitialized: false,\n        lastFetchedAt: null,\n        isCacheValid: ()=>{\n            const { lastFetchedAt } = get();\n            if (!lastFetchedAt) return false;\n            return Date.now() - lastFetchedAt < CACHE_TTL;\n        },\n        setUserId: (userId)=>{\n            const { userId: currentUserId } = get();\n            // Только если пользователь изменился\n            if (currentUserId !== userId) {\n                set({\n                    userId\n                });\n                if (userId) {\n                    get().loadFavorites(true); // Принудительное обновление при смене пользователя\n                }\n            }\n        },\n        addToFavorites: async (track)=>{\n            const { userId, favorites, actionsHistory, unreadActionsCount } = get();\n            // Проверяем, не добавлен ли уже\n            if (favorites.some((f)=>f.id === track.id)) {\n                return;\n            }\n            const favoriteTrack = {\n                ...track,\n                addedAt: new Date()\n            };\n            // Добавляем в историю действий\n            const action = {\n                type: \"add\",\n                track,\n                timestamp: new Date()\n            };\n            // Добавляем локально (в начало списка)\n            set({\n                favorites: [\n                    favoriteTrack,\n                    ...favorites\n                ],\n                actionsHistory: [\n                    action,\n                    ...actionsHistory\n                ].slice(0, 100),\n                unreadActionsCount: unreadActionsCount + 1\n            });\n            // Синхронизируем с сервером если есть userId\n            if (userId) {\n                try {\n                    await fetch(\"/api/favorites\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            userId,\n                            track\n                        })\n                    });\n                } catch (error) {\n                    console.error(\"Error syncing favorite to server:\", error);\n                }\n            }\n        },\n        removeFromFavorites: async (trackId)=>{\n            const { userId, favorites, actionsHistory, unreadActionsCount } = get();\n            // Находим трек для истории\n            const track = favorites.find((f)=>f.id === trackId);\n            // Добавляем в историю действий\n            if (track) {\n                const action = {\n                    type: \"remove\",\n                    track,\n                    timestamp: new Date()\n                };\n                set({\n                    actionsHistory: [\n                        action,\n                        ...actionsHistory\n                    ].slice(0, 100),\n                    unreadActionsCount: unreadActionsCount + 1\n                });\n            }\n            // Удаляем локально\n            set({\n                favorites: favorites.filter((f)=>f.id !== trackId)\n            });\n            // Синхронизируем с сервером если есть userId\n            if (userId) {\n                try {\n                    await fetch(\"/api/favorites?userId=\".concat(userId, \"&trackId=\").concat(trackId), {\n                        method: \"DELETE\"\n                    });\n                } catch (error) {\n                    console.error(\"Error removing favorite from server:\", error);\n                }\n            }\n        },\n        isFavorite: (trackId)=>{\n            return get().favorites.some((f)=>f.id === trackId);\n        },\n        loadFavorites: async function() {\n            let forceRefresh = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n            const { userId, isLoading, isCacheValid, favorites } = get();\n            if (!userId) return;\n            // Не загружаем повторно, если уже загружаем или кэш валиден\n            if (isLoading) return;\n            if (!forceRefresh && isCacheValid() && favorites.length > 0) {\n                console.log(\"[Favorites] Using cached data\");\n                return;\n            }\n            set({\n                isLoading: true\n            });\n            console.log(\"[Favorites] Loading from server...\");\n            try {\n                const response = await fetch(\"/api/favorites?userId=\".concat(userId));\n                const data = await response.json();\n                if (data.favorites && data.favorites.length > 0) {\n                    const favorites = data.favorites.map((f)=>({\n                            id: f.trackId,\n                            title: f.title,\n                            artist: f.artist,\n                            duration: f.duration,\n                            coverUrl: f.coverUrl,\n                            audioUrl: f.audioUrl,\n                            source: f.source,\n                            addedAt: new Date(f.addedAt),\n                            isAvailable: !!f.audioUrl\n                        }));\n                    set({\n                        favorites,\n                        isInitialized: true,\n                        lastFetchedAt: Date.now()\n                    });\n                } else {\n                    set({\n                        lastFetchedAt: Date.now()\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error loading favorites:\", error);\n            } finally{\n                set({\n                    isLoading: false\n                });\n            }\n        },\n        syncWithServer: async ()=>{\n            const { userId, favorites } = get();\n            if (!userId) return;\n            for (const track of favorites){\n                try {\n                    await fetch(\"/api/favorites\", {\n                        method: \"POST\",\n                        headers: {\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: JSON.stringify({\n                            userId,\n                            track\n                        })\n                    });\n                } catch (error) {\n                    console.error(\"Error syncing favorite:\", error);\n                }\n            }\n        },\n        // Массовое добавление без дубликатов (для первоначальной загрузки VK)\n        bulkAddToFavorites: (tracks)=>{\n            const { favorites } = get();\n            const existingIds = new Set(favorites.map((f)=>f.id));\n            const newTracks = tracks.filter((t)=>!existingIds.has(t.id)).map((t)=>({\n                    ...t,\n                    addedAt: new Date()\n                }));\n            if (newTracks.length > 0) {\n                // Добавляем новые треки в конец (VK треки как база)\n                set({\n                    favorites: [\n                        ...favorites,\n                        ...newTracks\n                    ],\n                    isInitialized: true\n                });\n            } else {\n                set({\n                    isInitialized: true\n                });\n            }\n        },\n        setInitialized: (value)=>{\n            set({\n                isInitialized: value\n            });\n        },\n        clearFavorites: ()=>{\n            set({\n                favorites: [],\n                isInitialized: false\n            });\n        },\n        clearActionsHistory: ()=>{\n            set({\n                actionsHistory: [],\n                unreadActionsCount: 0\n            });\n        },\n        markHistoryAsRead: ()=>{\n            set({\n                unreadActionsCount: 0\n            });\n        }\n    }), {\n    name: \"citrus-favorites\",\n    partialize: (state)=>({\n            favorites: state.favorites,\n            actionsHistory: state.actionsHistory,\n            unreadActionsCount: state.unreadActionsCount,\n            userId: state.userId,\n            isInitialized: state.isInitialized\n        })\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9mYXZvcml0ZXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7OztDQUdDLEdBRWdDO0FBQ1k7QUE2QzdDLDhCQUE4QjtBQUM5QixNQUFNRSxZQUFZLEtBQUssS0FBSztBQUVyQixNQUFNQyxvQkFBb0JILCtDQUFNQSxHQUNyQ0MsMkRBQU9BLENBQ0wsQ0FBQ0csS0FBS0MsTUFBUztRQUNiQyxXQUFXLEVBQUU7UUFDYkMsZ0JBQWdCLEVBQUU7UUFDbEJDLG9CQUFvQjtRQUNwQkMsUUFBUTtRQUNSQyxXQUFXO1FBQ1hDLGVBQWU7UUFDZkMsZUFBZTtRQUVmQyxjQUFjO1lBQ1osTUFBTSxFQUFFRCxhQUFhLEVBQUUsR0FBR1A7WUFDMUIsSUFBSSxDQUFDTyxlQUFlLE9BQU87WUFDM0IsT0FBT0UsS0FBS0MsR0FBRyxLQUFLSCxnQkFBZ0JWO1FBQ3RDO1FBRUFjLFdBQVcsQ0FBQ1A7WUFDVixNQUFNLEVBQUVBLFFBQVFRLGFBQWEsRUFBRSxHQUFHWjtZQUNsQyxxQ0FBcUM7WUFDckMsSUFBSVksa0JBQWtCUixRQUFRO2dCQUM1QkwsSUFBSTtvQkFBRUs7Z0JBQU87Z0JBQ2IsSUFBSUEsUUFBUTtvQkFDVkosTUFBTWEsYUFBYSxDQUFDLE9BQU8sbURBQW1EO2dCQUNoRjtZQUNGO1FBQ0Y7UUFFQUMsZ0JBQWdCLE9BQU9DO1lBQ3JCLE1BQU0sRUFBRVgsTUFBTSxFQUFFSCxTQUFTLEVBQUVDLGNBQWMsRUFBRUMsa0JBQWtCLEVBQUUsR0FBR0g7WUFFbEUsZ0NBQWdDO1lBQ2hDLElBQUlDLFVBQVVlLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsRUFBRSxLQUFLSCxNQUFNRyxFQUFFLEdBQUc7Z0JBQzFDO1lBQ0Y7WUFFQSxNQUFNQyxnQkFBK0I7Z0JBQ25DLEdBQUdKLEtBQUs7Z0JBQ1JLLFNBQVMsSUFBSVg7WUFDZjtZQUVBLCtCQUErQjtZQUMvQixNQUFNWSxTQUF5QjtnQkFDN0JDLE1BQU07Z0JBQ05Q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QUNqQzBCLEdBQUcsQ0FBQ2MsQ0FBQUEsSUFBTTtvQkFDVCxHQUFHQSxDQUFDO29CQUNKdEMsU0FBUyxJQUFJWDtnQkFDZjtZQUVGLElBQUlnRCxVQUFVbEIsTUFBTSxHQUFHLEdBQUc7Z0JBQ3hCLG9EQUFvRDtnQkFDcER4QyxJQUFJO29CQUNGRSxXQUFXOzJCQUFJQTsyQkFBY3dEO3FCQUFVO29CQUN2Q25ELGVBQWU7Z0JBQ2pCO1lBQ0YsT0FBTztnQkFDTFAsSUFBSTtvQkFBRU8sZUFBZTtnQkFBSztZQUM1QjtRQUNGO1FBRUFzRCxnQkFBZ0IsQ0FBQ0M7WUFDZjlELElBQUk7Z0JBQUVPLGVBQWV1RDtZQUFNO1FBQzdCO1FBRUFDLGdCQUFnQjtZQUNkL0QsSUFBSTtnQkFBRUUsV0FBVyxFQUFFO2dCQUFFSyxlQUFlO1lBQU07UUFDNUM7UUFFQXlELHFCQUFxQjtZQUNuQmhFLElBQUk7Z0JBQUVHLGdCQUFnQixFQUFFO2dCQUFFQyxvQkFBb0I7WUFBRTtRQUNsRDtRQUVBNkQsbUJBQW1CO1lBQ2pCakUsSUFBSTtnQkFBRUksb0JBQW9CO1lBQUU7UUFDOUI7SUFDRixJQUNBO0lBQ0U4RCxNQUFNO0lBQ05DLFlBQVksQ0FBQ0MsUUFBVztZQUN0QmxFLFdBQVdrRSxNQUFNbEUsU0FBUztZQUMxQkMsZ0JBQWdCaUUsTUFBTWpFLGNBQWM7WUFDcENDLG9CQUFvQmdFLE1BQU1oRSxrQkFBa0I7WUFDNUNDLFFBQVErRCxNQUFNL0QsTUFBTTtZQUNwQkUsZUFBZTZELE1BQU03RCxhQUFhO1FBQ3BDO0FBQ0YsSUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc3RvcmUvZmF2b3JpdGVzLnRzPzQwMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFN0b3JlINC00LvRjyDRg9C/0YDQsNCy0LvQtdC90LjRjyDQuNC30LHRgNCw0L3QvdGL0LzQuCDRgtGA0LXQutCw0LzQuFxyXG4gKiBAbW9kdWxlIHN0b3JlL2Zhdm9yaXRlc1xyXG4gKi9cclxuXHJcbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xyXG5pbXBvcnQgeyBwZXJzaXN0IH0gZnJvbSAnenVzdGFuZC9taWRkbGV3YXJlJztcclxuaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJ0AvdHlwZXMvYXVkaW8nO1xyXG5cclxuaW50ZXJmYWNlIEZhdm9yaXRlVHJhY2sgZXh0ZW5kcyBUcmFjayB7XHJcbiAgYWRkZWRBdDogRGF0ZTtcclxufVxyXG5cclxuLy8g0JjRgdGC0L7RgNC40Y8g0LTQtdC50YHRgtCy0LjQuSDRgSDQuNC30LHRgNCw0L3QvdGL0LxcclxuaW50ZXJmYWNlIEZhdm9yaXRlQWN0aW9uIHtcclxuICB0eXBlOiAnYWRkJyB8ICdyZW1vdmUnO1xyXG4gIHRyYWNrOiBUcmFjaztcclxuICB0aW1lc3RhbXA6IERhdGU7XHJcbn1cclxuXHJcbmludGVyZmFjZSBGYXZvcml0ZXNTdGF0ZSB7XHJcbiAgLy8g0JTQsNC90L3Ri9C1XHJcbiAgZmF2b3JpdGVzOiBGYXZvcml0ZVRyYWNrW107XHJcbiAgYWN0aW9uc0hpc3Rvcnk6IEZhdm9yaXRlQWN0aW9uW107XHJcbiAgdW5yZWFkQWN0aW9uc0NvdW50OiBudW1iZXI7IC8vINCa0L7Qu9C40YfQtdGB0YLQstC+INC90LXQv9GA0L7Rh9C40YLQsNC90L3Ri9GFINC00LXQudGB0YLQstC40LlcclxuICB1c2VySWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xyXG4gIGlzSW5pdGlhbGl6ZWQ6IGJvb2xlYW47IC8vINCk0LvQsNCzINGB0LjQvdGF0YDQvtC90LjQt9Cw0YbQuNC4INGBIFZLXHJcbiAgbGFzdEZldGNoZWRBdDogbnVtYmVyIHwgbnVsbDsgLy8g0JLRgNC10LzRjyDQv9C+0YHQu9C10LTQvdC10Lkg0LfQsNCz0YDRg9C30LrQuCDRgSDRgdC10YDQstC10YDQsFxyXG4gIFxyXG4gIC8vIEFjdGlvbnNcclxuICBzZXRVc2VySWQ6ICh1c2VySWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XHJcbiAgYWRkVG9GYXZvcml0ZXM6ICh0cmFjazogVHJhY2spID0+IFByb21pc2U8dm9pZD47XHJcbiAgcmVtb3ZlRnJvbUZhdm9yaXRlczogKHRyYWNrSWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICBpc0Zhdm9yaXRlOiAodHJhY2tJZDogc3RyaW5nKSA9PiBib29sZWFuO1xyXG4gIGxvYWRGYXZvcml0ZXM6IChmb3JjZVJlZnJlc2g/OiBib29sZWFuKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIHN5bmNXaXRoU2VydmVyOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gIFxyXG4gIC8vINCc0LDRgdGB0L7QstC+0LUg0LTQvtCx0LDQstC70LXQvdC40LUgKNC00LvRjyBWSylcclxuICBidWxrQWRkVG9GYXZvcml0ZXM6ICh0cmFja3M6IFRyYWNrW10pID0+IHZvaWQ7XHJcbiAgc2V0SW5pdGlhbGl6ZWQ6ICh2YWx1ZTogYm9vbGVhbikgPT4gdm9pZDtcclxuICBjbGVhckZhdm9yaXRlczogKCkgPT4gdm9pZDtcclxuICBjbGVhckFjdGlvbnNIaXN0b3J5OiAoKSA9PiB2b2lkO1xyXG4gIFxyXG4gIC8vINCe0YLQvNC10YLQuNGC0Ywg0LjRgdGC0L7RgNC40Y4g0LrQsNC6INC/0YDQvtGH0LjRgtCw0L3QvdGD0Y5cclxuICBtYXJrSGlzdG9yeUFzUmVhZDogKCkgPT4gdm9pZDtcclxuICBcclxuICAvLyDQn9GA0L7QstC10YDQutCwINC60Y3RiNCwXHJcbiAgaXNDYWNoZVZhbGlkOiAoKSA9PiBib29sZWFuO1xyXG59XHJcblxyXG4vLyDQktGA0LXQvNGPINC20LjQt9C90Lgg0LrRjdGI0LAgLSAzMCDQvNC40L3Rg9GCXHJcbmNvbnN0IENBQ0hFX1RUTCA9IDMwICogNjAgKiAxMDAwO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZUZhdm9yaXRlc1N0b3JlID0gY3JlYXRlPEZhdm9yaXRlc1N0YXRlPigpKFxyXG4gIHBlcnNpc3QoXHJcbiAgICAoc2V0LCBnZXQpID0+ICh7XHJcbiAgICAgIGZhdm9yaXRlczogW10sXHJcbiAgICAgIGFjdGlvbnNIaXN0b3J5OiBbXSxcclxuICAgICAgdW5yZWFkQWN0aW9uc0NvdW50OiAwLFxyXG4gICAgICB1c2VySWQ6IG51bGwsXHJcbiAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxyXG4gICAgICBsYXN0RmV0Y2hlZEF0OiBudWxsLFxyXG4gICAgICBcclxuICAgICAgaXNDYWNoZVZhbGlkOiAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBsYXN0RmV0Y2hlZEF0IH0gPSBnZXQoKTtcclxuICAgICAgICBpZiAoIWxhc3RGZXRjaGVkQXQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxhc3RGZXRjaGVkQXQgPCBDQUNIRV9UVEw7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBzZXRVc2VySWQ6ICh1c2VySWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZDogY3VycmVudFVzZXJJZCB9ID0gZ2V0KCk7XHJcbiAgICAgICAgLy8g0KLQvtC70YzQutC+INC10YHQu9C4INC/0L7Qu9GM0LfQvtCy0LDRgtC10LvRjCDQuNC30LzQtdC90LjQu9GB0Y9cclxuICAgICAgICBpZiAoY3VycmVudFVzZXJJZCAhPT0gdXNlcklkKSB7XHJcbiAgICAgICAgICBzZXQoeyB1c2VySWQgfSk7XHJcbiAgICAgICAgICBpZiAodXNlcklkKSB7XHJcbiAgICAgICAgICAgIGdldCgpLmxvYWRGYXZvcml0ZXModHJ1ZSk7IC8vINCf0YDQuNC90YPQtNC40YLQtdC70YzQvdC+0LUg0L7QsdC90L7QstC70LXQvdC40LUg0L/RgNC4INGB0LzQtdC90LUg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9GPXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgYWRkVG9GYXZvcml0ZXM6IGFzeW5jICh0cmFjaykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCBmYXZvcml0ZXMsIGFjdGlvbnNIaXN0b3J5LCB1bnJlYWRBY3Rpb25zQ291bnQgfSA9IGdldCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCf0YDQvtCy0LXRgNGP0LXQvCwg0L3QtSDQtNC+0LHQsNCy0LvQtdC9INC70Lgg0YPQttC1XHJcbiAgICAgICAgaWYgKGZhdm9yaXRlcy5zb21lKGYgPT4gZi5pZCA9PT0gdHJhY2suaWQpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGZhdm9yaXRlVHJhY2s6IEZhdm9yaXRlVHJhY2sgPSB7XHJcbiAgICAgICAgICAuLi50cmFjayxcclxuICAgICAgICAgIGFkZGVkQXQ6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LIg0LjRgdGC0L7RgNC40Y4g0LTQtdC50YHRgtCy0LjQuVxyXG4gICAgICAgIGNvbnN0IGFjdGlvbjogRmF2b3JpdGVBY3Rpb24gPSB7XHJcbiAgICAgICAgICB0eXBlOiAnYWRkJyxcclxuICAgICAgICAgIHRyYWNrLFxyXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0JTQvtCx0LDQstC70Y/QtdC8INC70L7QutCw0LvRjNC90L4gKNCyINC90LDRh9Cw0LvQviDRgdC/0LjRgdC60LApXHJcbiAgICAgICAgc2V0KHsgXHJcbiAgICAgICAgICBmYXZvcml0ZXM6IFtmYXZvcml0ZVRyYWNrLCAuLi5mYXZvcml0ZXNdLFxyXG4gICAgICAgICAgYWN0aW9uc0hpc3Rvcnk6IFthY3Rpb24sIC4uLmFjdGlvbnNIaXN0b3J5XS5zbGljZSgwLCAxMDApLCAvLyDQpdGA0LDQvdC40Lwg0L/QvtGB0LvQtdC00L3QuNC1IDEwMCDQtNC10LnRgdGC0LLQuNC5XHJcbiAgICAgICAgICB1bnJlYWRBY3Rpb25zQ291bnQ6IHVucmVhZEFjdGlvbnNDb3VudCArIDEsIC8vINCj0LLQtdC70LjRh9C40LLQsNC10Lwg0YHRh9C10YLRh9C40Log0L3QtdC/0YDQvtGH0LjRgtCw0L3QvdGL0YVcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQodC40L3RhdGA0L7QvdC40LfQuNGA0YPQtdC8INGBINGB0LXRgNCy0LXRgNC+0Lwg0LXRgdC70Lgg0LXRgdGC0YwgdXNlcklkXHJcbiAgICAgICAgaWYgKHVzZXJJZCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgZmV0Y2goJy9hcGkvZmF2b3JpdGVzJywge1xyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCB0cmFjayB9KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzeW5jaW5nIGZhdm9yaXRlIHRvIHNlcnZlcjonLCBlcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgcmVtb3ZlRnJvbUZhdm9yaXRlczogYXN5bmMgKHRyYWNrSWQpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZCwgZmF2b3JpdGVzLCBhY3Rpb25zSGlzdG9yeSwgdW5yZWFkQWN0aW9uc0NvdW50IH0gPSBnZXQoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQndCw0YXQvtC00LjQvCDRgtGA0LXQuiDQtNC70Y8g0LjRgdGC0L7RgNC40LhcclxuICAgICAgICBjb25zdCB0cmFjayA9IGZhdm9yaXRlcy5maW5kKGYgPT4gZi5pZCA9PT0gdHJhY2tJZCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8g0JTQvtCx0LDQstC70Y/QtdC8INCyINC40YHRgtC+0YDQuNGOINC00LXQudGB0YLQstC40LlcclxuICAgICAgICBpZiAodHJhY2spIHtcclxuICAgICAgICAgIGNvbnN0IGFjdGlvbjogRmF2b3JpdGVBY3Rpb24gPSB7XHJcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmUnLFxyXG4gICAgICAgICAgICB0cmFjayxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIHNldCh7IFxyXG4gICAgICAgICAgICBhY3Rpb25zSGlzdG9yeTogW2FjdGlvbiwgLi4uYWN0aW9uc0hpc3RvcnldLnNsaWNlKDAsIDEwMCksXHJcbiAgICAgICAgICAgIHVucmVhZEFjdGlvbnNDb3VudDogdW5yZWFkQWN0aW9uc0NvdW50ICsgMSwgLy8g0KPQstC10LvQuNGH0LjQstCw0LXQvCDRgdGH0LXRgtGH0LjQuiDQvdC10L/RgNC+0YfQuNGC0LDQvdC90YvRhVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vINCj0LTQsNC70Y/QtdC8INC70L7QutCw0LvRjNC90L5cclxuICAgICAgICBzZXQoeyBmYXZvcml0ZXM6IGZhdm9yaXRlcy5maWx0ZXIoZiA9PiBmLmlkICE9PSB0cmFja0lkKSB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQodC40L3RhdGA0L7QvdC40LfQuNGA0YPQtdC8INGBINGB0LXRgNCy0LXRgNC+0Lwg0LXRgdC70Lgg0LXRgdGC0YwgdXNlcklkXHJcbiAgICAgICAgaWYgKHVzZXJJZCkge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgZmV0Y2goYC9hcGkvZmF2b3JpdGVzP3VzZXJJZD0ke3VzZXJJZH0mdHJhY2tJZD0ke3RyYWNrSWR9YCwge1xyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgZmF2b3JpdGUgZnJvbSBzZXJ2ZXI6JywgZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIGlzRmF2b3JpdGU6ICh0cmFja0lkKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGdldCgpLmZhdm9yaXRlcy5zb21lKGYgPT4gZi5pZCA9PT0gdHJhY2tJZCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBsb2FkRmF2b3JpdGVzOiBhc3luYyAoZm9yY2VSZWZyZXNoID0gZmFsc2UpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZXJJZCwgaXNMb2FkaW5nLCBpc0NhY2hlVmFsaWQsIGZhdm9yaXRlcyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgaWYgKCF1c2VySWQpIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgICAvLyDQndC1INC30LDQs9GA0YPQttCw0LXQvCDQv9C+0LLRgtC+0YDQvdC+LCDQtdGB0LvQuCDRg9C20LUg0LfQsNCz0YDRg9C20LDQtdC8INC40LvQuCDQutGN0Ygg0LLQsNC70LjQtNC10L1cclxuICAgICAgICBpZiAoaXNMb2FkaW5nKSByZXR1cm47XHJcbiAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgaXNDYWNoZVZhbGlkKCkgJiYgZmF2b3JpdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdbRmF2b3JpdGVzXSBVc2luZyBjYWNoZWQgZGF0YScpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IHRydWUgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1tGYXZvcml0ZXNdIExvYWRpbmcgZnJvbSBzZXJ2ZXIuLi4nKTtcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9mYXZvcml0ZXM/dXNlcklkPSR7dXNlcklkfWApO1xyXG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGRhdGEuZmF2b3JpdGVzICYmIGRhdGEuZmF2b3JpdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZmF2b3JpdGVzOiBGYXZvcml0ZVRyYWNrW10gPSBkYXRhLmZhdm9yaXRlcy5tYXAoKGY6IGFueSkgPT4gKHtcclxuICAgICAgICAgICAgICBpZDogZi50cmFja0lkLFxyXG4gICAgICAgICAgICAgIHRpdGxlOiBmLnRpdGxlLFxyXG4gICAgICAgICAgICAgIGFydGlzdDogZi5hcnRpc3QsXHJcbiAgICAgICAgICAgICAgZHVyYXRpb246IGYuZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgY292ZXJVcmw6IGYuY292ZXJVcmwsXHJcbiAgICAgICAgICAgICAgYXVkaW9Vcmw6IGYuYXVkaW9VcmwsXHJcbiAgICAgICAgICAgICAgc291cmNlOiBmLnNvdXJjZSxcclxuICAgICAgICAgICAgICBhZGRlZEF0OiBuZXcgRGF0ZShmLmFkZGVkQXQpLFxyXG4gICAgICAgICAgICAgIGlzQXZhaWxhYmxlOiAhIWYuYXVkaW9VcmwsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgc2V0KHsgZmF2b3JpdGVzLCBpc0luaXRpYWxpemVkOiB0cnVlLCBsYXN0RmV0Y2hlZEF0OiBEYXRlLm5vdygpIH0pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2V0KHsgbGFzdEZldGNoZWRBdDogRGF0ZS5ub3coKSB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBmYXZvcml0ZXM6JywgZXJyb3IpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBzZXQoeyBpc0xvYWRpbmc6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgXHJcbiAgICAgIHN5bmNXaXRoU2VydmVyOiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIGZhdm9yaXRlcyB9ID0gZ2V0KCk7XHJcbiAgICAgICAgaWYgKCF1c2VySWQpIHJldHVybjtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIGZhdm9yaXRlcykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgYXdhaXQgZmV0Y2goJy9hcGkvZmF2b3JpdGVzJywge1xyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkLCB0cmFjayB9KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzeW5jaW5nIGZhdm9yaXRlOicsIGVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICAvLyDQnNCw0YHRgdC+0LLQvtC1INC00L7QsdCw0LLQu9C10L3QuNC1INCx0LXQtyDQtNGD0LHQu9C40LrQsNGC0L7QsiAo0LTQu9GPINC/0LXRgNCy0L7QvdCw0YfQsNC70YzQvdC+0Lkg0LfQsNCz0YDRg9C30LrQuCBWSylcclxuICAgICAgYnVsa0FkZFRvRmF2b3JpdGVzOiAodHJhY2tzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBmYXZvcml0ZXMgfSA9IGdldCgpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChmYXZvcml0ZXMubWFwKGYgPT4gZi5pZCkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IG5ld1RyYWNrczogRmF2b3JpdGVUcmFja1tdID0gdHJhY2tzXHJcbiAgICAgICAgICAuZmlsdGVyKHQgPT4gIWV4aXN0aW5nSWRzLmhhcyh0LmlkKSlcclxuICAgICAgICAgIC5tYXAodCA9PiAoe1xyXG4gICAgICAgICAgICAuLi50LFxyXG4gICAgICAgICAgICBhZGRlZEF0OiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChuZXdUcmFja3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgLy8g0JTQvtCx0LDQstC70Y/QtdC8INC90L7QstGL0LUg0YLRgNC10LrQuCDQsiDQutC+0L3QtdGGIChWSyDRgtGA0LXQutC4INC60LDQuiDQsdCw0LfQsClcclxuICAgICAgICAgIHNldCh7IFxyXG4gICAgICAgICAgICBmYXZvcml0ZXM6IFsuLi5mYXZvcml0ZXMsIC4uLm5ld1RyYWNrc10sXHJcbiAgICAgICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHRydWUsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2V0KHsgaXNJbml0aWFsaXplZDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBzZXRJbml0aWFsaXplZDogKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgc2V0KHsgaXNJbml0aWFsaXplZDogdmFsdWUgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIFxyXG4gICAgICBjbGVhckZhdm9yaXRlczogKCkgPT4ge1xyXG4gICAgICAgIHNldCh7IGZhdm9yaXRlczogW10sIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgY2xlYXJBY3Rpb25zSGlzdG9yeTogKCkgPT4ge1xyXG4gICAgICAgIHNldCh7IGFjdGlvbnNIaXN0b3J5OiBbXSwgdW5yZWFkQWN0aW9uc0NvdW50OiAwIH0pO1xyXG4gICAgICB9LFxyXG4gICAgICBcclxuICAgICAgbWFya0hpc3RvcnlBc1JlYWQ6ICgpID0+IHtcclxuICAgICAgICBzZXQoeyB1bnJlYWRBY3Rpb25zQ291bnQ6IDAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICB9KSxcclxuICAgIHtcclxuICAgICAgbmFtZTogJ2NpdHJ1cy1mYXZvcml0ZXMnLFxyXG4gICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7XHJcbiAgICAgICAgZmF2b3JpdGVzOiBzdGF0ZS5mYXZvcml0ZXMsXHJcbiAgICAgICAgYWN0aW9uc0hpc3Rvcnk6IHN0YXRlLmFjdGlvbnNIaXN0b3J5LFxyXG4gICAgICAgIHVucmVhZEFjdGlvbnNDb3VudDogc3RhdGUudW5yZWFkQWN0aW9uc0NvdW50LFxyXG4gICAgICAgIHVzZXJJZDogc3RhdGUudXNlcklkLFxyXG4gICAgICAgIGlzSW5pdGlhbGl6ZWQ6IHN0YXRlLmlzSW5pdGlhbGl6ZWQsXHJcbiAgICAgIH0pLFxyXG4gICAgfVxyXG4gIClcclxuKTtcclxuIl0sIm5hbWVzIjpbImNyZWF0ZSIsInBlcnNpc3QiLCJDQUNIRV9UVEwiLCJ1c2VGYXZvcml0ZXNTdG9yZSIsInNldCIsImdldCIsImZhdm9yaXRlcyIsImFjdGlvbnNIaXN0b3J5IiwidW5yZWFkQWN0aW9uc0NvdW50IiwidXNlcklkIiwiaXNMb2FkaW5nIiwiaXNJbml0aWFsaXplZCIsImxhc3RGZXRjaGVkQXQiLCJpc0NhY2hlVmFsaWQiLCJEYXRlIiwibm93Iiwic2V0VXNlcklkIiwiY3VycmVudFVzZXJJZCIsImxvYWRGYXZvcml0ZXMiLCJhZGRUb0Zhdm9yaXRlcyIsInRyYWNrIiwic29tZSIsImYiLCJpZCIsImZhdm9yaXRlVHJhY2siLCJhZGRlZEF0IiwiYWN0aW9uIiwidHlwZSIsInRpbWVzdGFtcCIsInNsaWNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJyZW1vdmVGcm9tRmF2b3JpdGVzIiwidHJhY2tJZCIsImZpbmQiLCJmaWx0ZXIiLCJpc0Zhdm9yaXRlIiwiZm9yY2VSZWZyZXNoIiwibGVuZ3RoIiwibG9nIiwicmVzcG9uc2UiLCJkYXRhIiwianNvbiIsIm1hcCIsInRpdGxlIiwiYXJ0aXN0IiwiZHVyYXRpb24iLCJjb3ZlclVybCIsImF1ZGlvVXJsIiwic291cmNlIiwiaXNBdmFpbGFibGUiLCJzeW5jV2l0aFNlcnZlciIsImJ1bGtBZGRUb0Zhdm9yaXRlcyIsInRyYWNrcyIsImV4aXN0aW5nSWRzIiwiU2V0IiwibmV3VHJhY2tzIiwidCIsImhhcyIsInNldEluaXRpYWxpemVkIiwidmFsdWUiLCJjbGVhckZhdm9yaXRlcyIsImNsZWFyQWN0aW9uc0hpc3RvcnkiLCJtYXJrSGlzdG9yeUFzUmVhZCIsIm5hbWUiLCJwYXJ0aWFsaXplIiwic3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/favorites.ts\n"));

/***/ })

});